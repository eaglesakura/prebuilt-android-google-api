// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/container/v1/cluster_service.proto

package com.google.container.v1;

/**
 * <pre>
 * Parameters that describe the nodes in a cluster.
 * </pre>
 *
 * Protobuf type {@code google.container.v1.NodeConfig}
 */
public  final class NodeConfig extends
    com.google.protobuf.GeneratedMessageLite<
        NodeConfig, NodeConfig.Builder> implements
    // @@protoc_insertion_point(message_implements:google.container.v1.NodeConfig)
    NodeConfigOrBuilder {
  private NodeConfig() {
    machineType_ = "";
    oauthScopes_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    serviceAccount_ = "";
    imageType_ = "";
    tags_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  private int bitField0_;
  public static final int MACHINE_TYPE_FIELD_NUMBER = 1;
  private java.lang.String machineType_;
  /**
   * <pre>
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   * </pre>
   *
   * <code>optional string machine_type = 1;</code>
   */
  public java.lang.String getMachineType() {
    return machineType_;
  }
  /**
   * <pre>
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   * </pre>
   *
   * <code>optional string machine_type = 1;</code>
   */
  public com.google.protobuf.ByteString
      getMachineTypeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(machineType_);
  }
  /**
   * <pre>
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   * </pre>
   *
   * <code>optional string machine_type = 1;</code>
   */
  private void setMachineType(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    machineType_ = value;
  }
  /**
   * <pre>
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   * </pre>
   *
   * <code>optional string machine_type = 1;</code>
   */
  private void clearMachineType() {
    
    machineType_ = getDefaultInstance().getMachineType();
  }
  /**
   * <pre>
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   * </pre>
   *
   * <code>optional string machine_type = 1;</code>
   */
  private void setMachineTypeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    machineType_ = value.toStringUtf8();
  }

  public static final int DISK_SIZE_GB_FIELD_NUMBER = 2;
  private int diskSizeGb_;
  /**
   * <pre>
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   * If unspecified, the default disk size is 100GB.
   * </pre>
   *
   * <code>optional int32 disk_size_gb = 2;</code>
   */
  public int getDiskSizeGb() {
    return diskSizeGb_;
  }
  /**
   * <pre>
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   * If unspecified, the default disk size is 100GB.
   * </pre>
   *
   * <code>optional int32 disk_size_gb = 2;</code>
   */
  private void setDiskSizeGb(int value) {
    
    diskSizeGb_ = value;
  }
  /**
   * <pre>
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   * If unspecified, the default disk size is 100GB.
   * </pre>
   *
   * <code>optional int32 disk_size_gb = 2;</code>
   */
  private void clearDiskSizeGb() {
    
    diskSizeGb_ = 0;
  }

  public static final int OAUTH_SCOPES_FIELD_NUMBER = 3;
  private com.google.protobuf.Internal.ProtobufList<String> oauthScopes_;
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  public java.util.List<String> getOauthScopesList() {
    return oauthScopes_;
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  public int getOauthScopesCount() {
    return oauthScopes_.size();
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  public java.lang.String getOauthScopes(int index) {
    return oauthScopes_.get(index);
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  public com.google.protobuf.ByteString
      getOauthScopesBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        oauthScopes_.get(index));
  }
  private void ensureOauthScopesIsMutable() {
    if (!oauthScopes_.isModifiable()) {
      oauthScopes_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(oauthScopes_);
     }
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  private void setOauthScopes(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureOauthScopesIsMutable();
    oauthScopes_.set(index, value);
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  private void addOauthScopes(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureOauthScopesIsMutable();
    oauthScopes_.add(value);
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  private void addAllOauthScopes(
      java.lang.Iterable<java.lang.String> values) {
    ensureOauthScopesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, oauthScopes_);
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  private void clearOauthScopes() {
    oauthScopes_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   * The following scopes are recommended, but not required, and by default are
   * not included:
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   * </pre>
   *
   * <code>repeated string oauth_scopes = 3;</code>
   */
  private void addOauthScopesBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureOauthScopesIsMutable();
    oauthScopes_.add(value.toStringUtf8());
  }

  public static final int SERVICE_ACCOUNT_FIELD_NUMBER = 9;
  private java.lang.String serviceAccount_;
  /**
   * <pre>
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   * </pre>
   *
   * <code>optional string service_account = 9;</code>
   */
  public java.lang.String getServiceAccount() {
    return serviceAccount_;
  }
  /**
   * <pre>
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   * </pre>
   *
   * <code>optional string service_account = 9;</code>
   */
  public com.google.protobuf.ByteString
      getServiceAccountBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(serviceAccount_);
  }
  /**
   * <pre>
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   * </pre>
   *
   * <code>optional string service_account = 9;</code>
   */
  private void setServiceAccount(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    serviceAccount_ = value;
  }
  /**
   * <pre>
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   * </pre>
   *
   * <code>optional string service_account = 9;</code>
   */
  private void clearServiceAccount() {
    
    serviceAccount_ = getDefaultInstance().getServiceAccount();
  }
  /**
   * <pre>
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   * </pre>
   *
   * <code>optional string service_account = 9;</code>
   */
  private void setServiceAccountBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    serviceAccount_ = value.toStringUtf8();
  }

  public static final int METADATA_FIELD_NUMBER = 4;
  private static final class MetadataDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.String, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.String, java.lang.String>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.String, java.lang.String> metadata_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
  internalGetMetadata() {
    return metadata_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
  internalGetMutableMetadata() {
    if (!metadata_.isMutable()) {
      metadata_ = metadata_.mutableCopy();
    }
    return metadata_;
  }

  public int getMetadataCount() {
    return internalGetMetadata().size();
  }
  /**
   * <pre>
   * The metadata key/value pairs assigned to instances in the cluster.
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   * The total size of all keys and values must be less than 512 KB.
   * </pre>
   *
   * <code>map&lt;string, string&gt; metadata = 4;</code>
   */

  public boolean containsMetadata(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    return internalGetMetadata().containsKey(key);
  }
  /**
   * Use {@link #getMetadataMap()} instead.
   */
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.String> getMetadata() {
    return getMetadataMap();
  }
  /**
   * <pre>
   * The metadata key/value pairs assigned to instances in the cluster.
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   * The total size of all keys and values must be less than 512 KB.
   * </pre>
   *
   * <code>map&lt;string, string&gt; metadata = 4;</code>
   */

  public java.util.Map<java.lang.String, java.lang.String> getMetadataMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetMetadata());
  }
  /**
   * <pre>
   * The metadata key/value pairs assigned to instances in the cluster.
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   * The total size of all keys and values must be less than 512 KB.
   * </pre>
   *
   * <code>map&lt;string, string&gt; metadata = 4;</code>
   */

  public java.lang.String getMetadataOrDefault(
      java.lang.String key,
      java.lang.String defaultValue) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetMetadata();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * The metadata key/value pairs assigned to instances in the cluster.
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   * The total size of all keys and values must be less than 512 KB.
   * </pre>
   *
   * <code>map&lt;string, string&gt; metadata = 4;</code>
   */

  public java.lang.String getMetadataOrThrow(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetMetadata();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * The metadata key/value pairs assigned to instances in the cluster.
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   * The total size of all keys and values must be less than 512 KB.
   * </pre>
   *
   * <code>map&lt;string, string&gt; metadata = 4;</code>
   */
  private java.util.Map<java.lang.String, java.lang.String>
  getMutableMetadataMap() {
    return internalGetMutableMetadata();
  }

  public static final int IMAGE_TYPE_FIELD_NUMBER = 5;
  private java.lang.String imageType_;
  /**
   * <pre>
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   * </pre>
   *
   * <code>optional string image_type = 5;</code>
   */
  public java.lang.String getImageType() {
    return imageType_;
  }
  /**
   * <pre>
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   * </pre>
   *
   * <code>optional string image_type = 5;</code>
   */
  public com.google.protobuf.ByteString
      getImageTypeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(imageType_);
  }
  /**
   * <pre>
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   * </pre>
   *
   * <code>optional string image_type = 5;</code>
   */
  private void setImageType(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    imageType_ = value;
  }
  /**
   * <pre>
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   * </pre>
   *
   * <code>optional string image_type = 5;</code>
   */
  private void clearImageType() {
    
    imageType_ = getDefaultInstance().getImageType();
  }
  /**
   * <pre>
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   * </pre>
   *
   * <code>optional string image_type = 5;</code>
   */
  private void setImageTypeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    imageType_ = value.toStringUtf8();
  }

  public static final int LABELS_FIELD_NUMBER = 6;
  private static final class LabelsDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.String, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.String, java.lang.String>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.String, java.lang.String> labels_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
  internalGetLabels() {
    return labels_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
  internalGetMutableLabels() {
    if (!labels_.isMutable()) {
      labels_ = labels_.mutableCopy();
    }
    return labels_;
  }

  public int getLabelsCount() {
    return internalGetLabels().size();
  }
  /**
   * <pre>
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * http://kubernetes.io/v1.1/docs/user-guide/labels.html
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public boolean containsLabels(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    return internalGetLabels().containsKey(key);
  }
  /**
   * Use {@link #getLabelsMap()} instead.
   */
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.String> getLabels() {
    return getLabelsMap();
  }
  /**
   * <pre>
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * http://kubernetes.io/v1.1/docs/user-guide/labels.html
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetLabels());
  }
  /**
   * <pre>
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * http://kubernetes.io/v1.1/docs/user-guide/labels.html
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public java.lang.String getLabelsOrDefault(
      java.lang.String key,
      java.lang.String defaultValue) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetLabels();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * http://kubernetes.io/v1.1/docs/user-guide/labels.html
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public java.lang.String getLabelsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetLabels();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * http://kubernetes.io/v1.1/docs/user-guide/labels.html
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */
  private java.util.Map<java.lang.String, java.lang.String>
  getMutableLabelsMap() {
    return internalGetMutableLabels();
  }

  public static final int LOCAL_SSD_COUNT_FIELD_NUMBER = 7;
  private int localSsdCount_;
  /**
   * <pre>
   * The number of local SSD disks to be attached to the node.
   * The limit for this value is dependant upon the maximum number of
   * disks available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
   * for more information.
   * </pre>
   *
   * <code>optional int32 local_ssd_count = 7;</code>
   */
  public int getLocalSsdCount() {
    return localSsdCount_;
  }
  /**
   * <pre>
   * The number of local SSD disks to be attached to the node.
   * The limit for this value is dependant upon the maximum number of
   * disks available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
   * for more information.
   * </pre>
   *
   * <code>optional int32 local_ssd_count = 7;</code>
   */
  private void setLocalSsdCount(int value) {
    
    localSsdCount_ = value;
  }
  /**
   * <pre>
   * The number of local SSD disks to be attached to the node.
   * The limit for this value is dependant upon the maximum number of
   * disks available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
   * for more information.
   * </pre>
   *
   * <code>optional int32 local_ssd_count = 7;</code>
   */
  private void clearLocalSsdCount() {
    
    localSsdCount_ = 0;
  }

  public static final int TAGS_FIELD_NUMBER = 8;
  private com.google.protobuf.Internal.ProtobufList<String> tags_;
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  public java.util.List<String> getTagsList() {
    return tags_;
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  public int getTagsCount() {
    return tags_.size();
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  public java.lang.String getTags(int index) {
    return tags_.get(index);
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  public com.google.protobuf.ByteString
      getTagsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        tags_.get(index));
  }
  private void ensureTagsIsMutable() {
    if (!tags_.isModifiable()) {
      tags_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(tags_);
     }
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  private void setTags(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureTagsIsMutable();
    tags_.set(index, value);
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  private void addTags(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureTagsIsMutable();
    tags_.add(value);
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  private void addAllTags(
      java.lang.Iterable<java.lang.String> values) {
    ensureTagsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, tags_);
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  private void clearTags() {
    tags_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   * </pre>
   *
   * <code>repeated string tags = 8;</code>
   */
  private void addTagsBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureTagsIsMutable();
    tags_.add(value.toStringUtf8());
  }

  public static final int PREEMPTIBLE_FIELD_NUMBER = 10;
  private boolean preemptible_;
  /**
   * <pre>
   * Whether the nodes are created as preemptible VM instances. See:
   * https://cloud.google.com/compute/docs/instances/preemptible for more
   * inforamtion about preemptible VM instances.
   * </pre>
   *
   * <code>optional bool preemptible = 10;</code>
   */
  public boolean getPreemptible() {
    return preemptible_;
  }
  /**
   * <pre>
   * Whether the nodes are created as preemptible VM instances. See:
   * https://cloud.google.com/compute/docs/instances/preemptible for more
   * inforamtion about preemptible VM instances.
   * </pre>
   *
   * <code>optional bool preemptible = 10;</code>
   */
  private void setPreemptible(boolean value) {
    
    preemptible_ = value;
  }
  /**
   * <pre>
   * Whether the nodes are created as preemptible VM instances. See:
   * https://cloud.google.com/compute/docs/instances/preemptible for more
   * inforamtion about preemptible VM instances.
   * </pre>
   *
   * <code>optional bool preemptible = 10;</code>
   */
  private void clearPreemptible() {
    
    preemptible_ = false;
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!machineType_.isEmpty()) {
      output.writeString(1, getMachineType());
    }
    if (diskSizeGb_ != 0) {
      output.writeInt32(2, diskSizeGb_);
    }
    for (int i = 0; i < oauthScopes_.size(); i++) {
      output.writeString(3, oauthScopes_.get(i));
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetMetadata().entrySet()) {
      MetadataDefaultEntryHolder.defaultEntry.serializeTo(
          output, 4, entry.getKey(), entry.getValue());
    }
    if (!imageType_.isEmpty()) {
      output.writeString(5, getImageType());
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetLabels().entrySet()) {
      LabelsDefaultEntryHolder.defaultEntry.serializeTo(
          output, 6, entry.getKey(), entry.getValue());
    }
    if (localSsdCount_ != 0) {
      output.writeInt32(7, localSsdCount_);
    }
    for (int i = 0; i < tags_.size(); i++) {
      output.writeString(8, tags_.get(i));
    }
    if (!serviceAccount_.isEmpty()) {
      output.writeString(9, getServiceAccount());
    }
    if (preemptible_ != false) {
      output.writeBool(10, preemptible_);
    }
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (!machineType_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(1, getMachineType());
    }
    if (diskSizeGb_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(2, diskSizeGb_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < oauthScopes_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(oauthScopes_.get(i));
      }
      size += dataSize;
      size += 1 * getOauthScopesList().size();
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetMetadata().entrySet()) {
      size += MetadataDefaultEntryHolder.defaultEntry.computeMessageSize(
        4, entry.getKey(), entry.getValue());
    }
    if (!imageType_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(5, getImageType());
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetLabels().entrySet()) {
      size += LabelsDefaultEntryHolder.defaultEntry.computeMessageSize(
        6, entry.getKey(), entry.getValue());
    }
    if (localSsdCount_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(7, localSsdCount_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < tags_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(tags_.get(i));
      }
      size += dataSize;
      size += 1 * getTagsList().size();
    }
    if (!serviceAccount_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(9, getServiceAccount());
    }
    if (preemptible_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(10, preemptible_);
    }
    memoizedSerializedSize = size;
    return size;
  }

  public static com.google.container.v1.NodeConfig parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.container.v1.NodeConfig parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.container.v1.NodeConfig parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.container.v1.NodeConfig parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.container.v1.NodeConfig parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.NodeConfig parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.container.v1.NodeConfig parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.NodeConfig parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.container.v1.NodeConfig parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.NodeConfig parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.container.v1.NodeConfig prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * Parameters that describe the nodes in a cluster.
   * </pre>
   *
   * Protobuf type {@code google.container.v1.NodeConfig}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.container.v1.NodeConfig, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.container.v1.NodeConfig)
      com.google.container.v1.NodeConfigOrBuilder {
    // Construct using com.google.container.v1.NodeConfig.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The name of a Google Compute Engine [machine
     * type](/compute/docs/machine-types) (e.g.
     * `n1-standard-1`).
     * If unspecified, the default machine type is
     * `n1-standard-1`.
     * </pre>
     *
     * <code>optional string machine_type = 1;</code>
     */
    public java.lang.String getMachineType() {
      return instance.getMachineType();
    }
    /**
     * <pre>
     * The name of a Google Compute Engine [machine
     * type](/compute/docs/machine-types) (e.g.
     * `n1-standard-1`).
     * If unspecified, the default machine type is
     * `n1-standard-1`.
     * </pre>
     *
     * <code>optional string machine_type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getMachineTypeBytes() {
      return instance.getMachineTypeBytes();
    }
    /**
     * <pre>
     * The name of a Google Compute Engine [machine
     * type](/compute/docs/machine-types) (e.g.
     * `n1-standard-1`).
     * If unspecified, the default machine type is
     * `n1-standard-1`.
     * </pre>
     *
     * <code>optional string machine_type = 1;</code>
     */
    public Builder setMachineType(
        java.lang.String value) {
      copyOnWrite();
      instance.setMachineType(value);
      return this;
    }
    /**
     * <pre>
     * The name of a Google Compute Engine [machine
     * type](/compute/docs/machine-types) (e.g.
     * `n1-standard-1`).
     * If unspecified, the default machine type is
     * `n1-standard-1`.
     * </pre>
     *
     * <code>optional string machine_type = 1;</code>
     */
    public Builder clearMachineType() {
      copyOnWrite();
      instance.clearMachineType();
      return this;
    }
    /**
     * <pre>
     * The name of a Google Compute Engine [machine
     * type](/compute/docs/machine-types) (e.g.
     * `n1-standard-1`).
     * If unspecified, the default machine type is
     * `n1-standard-1`.
     * </pre>
     *
     * <code>optional string machine_type = 1;</code>
     */
    public Builder setMachineTypeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setMachineTypeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Size of the disk attached to each node, specified in GB.
     * The smallest allowed disk size is 10GB.
     * If unspecified, the default disk size is 100GB.
     * </pre>
     *
     * <code>optional int32 disk_size_gb = 2;</code>
     */
    public int getDiskSizeGb() {
      return instance.getDiskSizeGb();
    }
    /**
     * <pre>
     * Size of the disk attached to each node, specified in GB.
     * The smallest allowed disk size is 10GB.
     * If unspecified, the default disk size is 100GB.
     * </pre>
     *
     * <code>optional int32 disk_size_gb = 2;</code>
     */
    public Builder setDiskSizeGb(int value) {
      copyOnWrite();
      instance.setDiskSizeGb(value);
      return this;
    }
    /**
     * <pre>
     * Size of the disk attached to each node, specified in GB.
     * The smallest allowed disk size is 10GB.
     * If unspecified, the default disk size is 100GB.
     * </pre>
     *
     * <code>optional int32 disk_size_gb = 2;</code>
     */
    public Builder clearDiskSizeGb() {
      copyOnWrite();
      instance.clearDiskSizeGb();
      return this;
    }

    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public java.util.List<String>
        getOauthScopesList() {
      return java.util.Collections.unmodifiableList(
          instance.getOauthScopesList());
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public int getOauthScopesCount() {
      return instance.getOauthScopesCount();
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public java.lang.String getOauthScopes(int index) {
      return instance.getOauthScopes(index);
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public com.google.protobuf.ByteString
        getOauthScopesBytes(int index) {
      return instance.getOauthScopesBytes(index);
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public Builder setOauthScopes(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setOauthScopes(index, value);
      return this;
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public Builder addOauthScopes(
        java.lang.String value) {
      copyOnWrite();
      instance.addOauthScopes(value);
      return this;
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public Builder addAllOauthScopes(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllOauthScopes(values);
      return this;
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public Builder clearOauthScopes() {
      copyOnWrite();
      instance.clearOauthScopes();
      return this;
    }
    /**
     * <pre>
     * The set of Google API scopes to be made available on all of the
     * node VMs under the "default" service account.
     * The following scopes are recommended, but not required, and by default are
     * not included:
     * * `https://www.googleapis.com/auth/compute` is required for mounting
     * persistent storage on your nodes.
     * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
     * communicating with **gcr.io**
     * (the [Google Container Registry](/container-registry/)).
     * If unspecified, no scopes are added, unless Cloud Logging or Cloud
     * Monitoring are enabled, in which case their required scopes will be added.
     * </pre>
     *
     * <code>repeated string oauth_scopes = 3;</code>
     */
    public Builder addOauthScopesBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addOauthScopesBytes(value);
      return this;
    }

    /**
     * <pre>
     * The Google Cloud Platform Service Account to be used by the node VMs. If
     * no Service Account is specified, the "default" service account is used.
     * </pre>
     *
     * <code>optional string service_account = 9;</code>
     */
    public java.lang.String getServiceAccount() {
      return instance.getServiceAccount();
    }
    /**
     * <pre>
     * The Google Cloud Platform Service Account to be used by the node VMs. If
     * no Service Account is specified, the "default" service account is used.
     * </pre>
     *
     * <code>optional string service_account = 9;</code>
     */
    public com.google.protobuf.ByteString
        getServiceAccountBytes() {
      return instance.getServiceAccountBytes();
    }
    /**
     * <pre>
     * The Google Cloud Platform Service Account to be used by the node VMs. If
     * no Service Account is specified, the "default" service account is used.
     * </pre>
     *
     * <code>optional string service_account = 9;</code>
     */
    public Builder setServiceAccount(
        java.lang.String value) {
      copyOnWrite();
      instance.setServiceAccount(value);
      return this;
    }
    /**
     * <pre>
     * The Google Cloud Platform Service Account to be used by the node VMs. If
     * no Service Account is specified, the "default" service account is used.
     * </pre>
     *
     * <code>optional string service_account = 9;</code>
     */
    public Builder clearServiceAccount() {
      copyOnWrite();
      instance.clearServiceAccount();
      return this;
    }
    /**
     * <pre>
     * The Google Cloud Platform Service Account to be used by the node VMs. If
     * no Service Account is specified, the "default" service account is used.
     * </pre>
     *
     * <code>optional string service_account = 9;</code>
     */
    public Builder setServiceAccountBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setServiceAccountBytes(value);
      return this;
    }


    public int getMetadataCount() {
      return instance.getMetadataMap().size();
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */

    public boolean containsMetadata(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return instance.getMetadataMap().containsKey(key);
    }

    public Builder clearMetadata() {
      copyOnWrite();
      instance.getMutableMetadataMap().clear();
      return this;
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */

    public Builder removeMetadata(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      copyOnWrite();
      instance.getMutableMetadataMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getMetadataMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getMetadata() {
      return getMetadataMap();
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */
    public java.util.Map<java.lang.String, java.lang.String> getMetadataMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getMetadataMap());
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */

    public java.lang.String getMetadataOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          instance.getMetadataMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */

    public java.lang.String getMetadataOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          instance.getMetadataMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */
    public Builder putMetadata(
        java.lang.String key,
        java.lang.String value) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      if (value == null) { throw new java.lang.NullPointerException(); }
      copyOnWrite();
      instance.getMutableMetadataMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * The metadata key/value pairs assigned to instances in the cluster.
     * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
     * in length. These are reflected as part of a URL in the metadata server.
     * Additionally, to avoid ambiguity, keys must not conflict with any other
     * metadata keys for the project or be one of the four reserved keys:
     * "instance-template", "kube-env", "startup-script", and "user-data"
     * Values are free-form strings, and only have meaning as interpreted by
     * the image running in the instance. The only restriction placed on them is
     * that each value's size must be less than or equal to 32 KB.
     * The total size of all keys and values must be less than 512 KB.
     * </pre>
     *
     * <code>map&lt;string, string&gt; metadata = 4;</code>
     */
    public Builder putAllMetadata(
        java.util.Map<java.lang.String, java.lang.String> values) {
      copyOnWrite();
      instance.getMutableMetadataMap().putAll(values);
      return this;
    }

    /**
     * <pre>
     * The image type to use for this node. Note that for a given image type,
     * the latest version of it will be used.
     * </pre>
     *
     * <code>optional string image_type = 5;</code>
     */
    public java.lang.String getImageType() {
      return instance.getImageType();
    }
    /**
     * <pre>
     * The image type to use for this node. Note that for a given image type,
     * the latest version of it will be used.
     * </pre>
     *
     * <code>optional string image_type = 5;</code>
     */
    public com.google.protobuf.ByteString
        getImageTypeBytes() {
      return instance.getImageTypeBytes();
    }
    /**
     * <pre>
     * The image type to use for this node. Note that for a given image type,
     * the latest version of it will be used.
     * </pre>
     *
     * <code>optional string image_type = 5;</code>
     */
    public Builder setImageType(
        java.lang.String value) {
      copyOnWrite();
      instance.setImageType(value);
      return this;
    }
    /**
     * <pre>
     * The image type to use for this node. Note that for a given image type,
     * the latest version of it will be used.
     * </pre>
     *
     * <code>optional string image_type = 5;</code>
     */
    public Builder clearImageType() {
      copyOnWrite();
      instance.clearImageType();
      return this;
    }
    /**
     * <pre>
     * The image type to use for this node. Note that for a given image type,
     * the latest version of it will be used.
     * </pre>
     *
     * <code>optional string image_type = 5;</code>
     */
    public Builder setImageTypeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setImageTypeBytes(value);
      return this;
    }


    public int getLabelsCount() {
      return instance.getLabelsMap().size();
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public boolean containsLabels(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return instance.getLabelsMap().containsKey(key);
    }

    public Builder clearLabels() {
      copyOnWrite();
      instance.getMutableLabelsMap().clear();
      return this;
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public Builder removeLabels(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      copyOnWrite();
      instance.getMutableLabelsMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getLabelsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getLabels() {
      return getLabelsMap();
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */
    public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getLabelsMap());
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public java.lang.String getLabelsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          instance.getLabelsMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public java.lang.String getLabelsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          instance.getLabelsMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */
    public Builder putLabels(
        java.lang.String key,
        java.lang.String value) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      if (value == null) { throw new java.lang.NullPointerException(); }
      copyOnWrite();
      instance.getMutableLabelsMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * The map of Kubernetes labels (key/value pairs) to be applied to each node.
     * These will added in addition to any default label(s) that
     * Kubernetes may apply to the node.
     * In case of conflict in label keys, the applied set may differ depending on
     * the Kubernetes version -- it's best to assume the behavior is undefined
     * and conflicts should be avoided.
     * For more information, including usage and the valid values, see:
     * http://kubernetes.io/v1.1/docs/user-guide/labels.html
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */
    public Builder putAllLabels(
        java.util.Map<java.lang.String, java.lang.String> values) {
      copyOnWrite();
      instance.getMutableLabelsMap().putAll(values);
      return this;
    }

    /**
     * <pre>
     * The number of local SSD disks to be attached to the node.
     * The limit for this value is dependant upon the maximum number of
     * disks available on a machine per zone. See:
     * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
     * for more information.
     * </pre>
     *
     * <code>optional int32 local_ssd_count = 7;</code>
     */
    public int getLocalSsdCount() {
      return instance.getLocalSsdCount();
    }
    /**
     * <pre>
     * The number of local SSD disks to be attached to the node.
     * The limit for this value is dependant upon the maximum number of
     * disks available on a machine per zone. See:
     * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
     * for more information.
     * </pre>
     *
     * <code>optional int32 local_ssd_count = 7;</code>
     */
    public Builder setLocalSsdCount(int value) {
      copyOnWrite();
      instance.setLocalSsdCount(value);
      return this;
    }
    /**
     * <pre>
     * The number of local SSD disks to be attached to the node.
     * The limit for this value is dependant upon the maximum number of
     * disks available on a machine per zone. See:
     * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
     * for more information.
     * </pre>
     *
     * <code>optional int32 local_ssd_count = 7;</code>
     */
    public Builder clearLocalSsdCount() {
      copyOnWrite();
      instance.clearLocalSsdCount();
      return this;
    }

    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public java.util.List<String>
        getTagsList() {
      return java.util.Collections.unmodifiableList(
          instance.getTagsList());
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public int getTagsCount() {
      return instance.getTagsCount();
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public java.lang.String getTags(int index) {
      return instance.getTags(index);
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public com.google.protobuf.ByteString
        getTagsBytes(int index) {
      return instance.getTagsBytes(index);
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public Builder setTags(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setTags(index, value);
      return this;
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public Builder addTags(
        java.lang.String value) {
      copyOnWrite();
      instance.addTags(value);
      return this;
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public Builder addAllTags(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllTags(values);
      return this;
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public Builder clearTags() {
      copyOnWrite();
      instance.clearTags();
      return this;
    }
    /**
     * <pre>
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls and are specified by
     * the client during cluster or node pool creation. Each tag within the list
     * must comply with RFC1035.
     * </pre>
     *
     * <code>repeated string tags = 8;</code>
     */
    public Builder addTagsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addTagsBytes(value);
      return this;
    }

    /**
     * <pre>
     * Whether the nodes are created as preemptible VM instances. See:
     * https://cloud.google.com/compute/docs/instances/preemptible for more
     * inforamtion about preemptible VM instances.
     * </pre>
     *
     * <code>optional bool preemptible = 10;</code>
     */
    public boolean getPreemptible() {
      return instance.getPreemptible();
    }
    /**
     * <pre>
     * Whether the nodes are created as preemptible VM instances. See:
     * https://cloud.google.com/compute/docs/instances/preemptible for more
     * inforamtion about preemptible VM instances.
     * </pre>
     *
     * <code>optional bool preemptible = 10;</code>
     */
    public Builder setPreemptible(boolean value) {
      copyOnWrite();
      instance.setPreemptible(value);
      return this;
    }
    /**
     * <pre>
     * Whether the nodes are created as preemptible VM instances. See:
     * https://cloud.google.com/compute/docs/instances/preemptible for more
     * inforamtion about preemptible VM instances.
     * </pre>
     *
     * <code>optional bool preemptible = 10;</code>
     */
    public Builder clearPreemptible() {
      copyOnWrite();
      instance.clearPreemptible();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.container.v1.NodeConfig)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.container.v1.NodeConfig();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        oauthScopes_.makeImmutable();
        metadata_.makeImmutable();
        labels_.makeImmutable();
        tags_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        com.google.container.v1.NodeConfig other = (com.google.container.v1.NodeConfig) arg1;
        machineType_ = visitor.visitString(!machineType_.isEmpty(), machineType_,
            !other.machineType_.isEmpty(), other.machineType_);
        diskSizeGb_ = visitor.visitInt(diskSizeGb_ != 0, diskSizeGb_,
            other.diskSizeGb_ != 0, other.diskSizeGb_);
        oauthScopes_= visitor.visitList(oauthScopes_, other.oauthScopes_);
        serviceAccount_ = visitor.visitString(!serviceAccount_.isEmpty(), serviceAccount_,
            !other.serviceAccount_.isEmpty(), other.serviceAccount_);
        metadata_ = visitor.visitMap(
            metadata_, other.internalGetMetadata());
        imageType_ = visitor.visitString(!imageType_.isEmpty(), imageType_,
            !other.imageType_.isEmpty(), other.imageType_);
        labels_ = visitor.visitMap(
            labels_, other.internalGetLabels());
        localSsdCount_ = visitor.visitInt(localSsdCount_ != 0, localSsdCount_,
            other.localSsdCount_ != 0, other.localSsdCount_);
        tags_= visitor.visitList(tags_, other.tags_);
        preemptible_ = visitor.visitBoolean(preemptible_ != false, preemptible_,
            other.preemptible_ != false, other.preemptible_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                String s = input.readStringRequireUtf8();

                machineType_ = s;
                break;
              }
              case 16: {

                diskSizeGb_ = input.readInt32();
                break;
              }
              case 26: {
                String s = input.readStringRequireUtf8();
                if (!oauthScopes_.isModifiable()) {
                  oauthScopes_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(oauthScopes_);
                }
                oauthScopes_.add(s);
                break;
              }
              case 34: {
                if (!metadata_.isMutable()) {
                  metadata_ = metadata_.mutableCopy();
                }
                MetadataDefaultEntryHolder.defaultEntry.parseInto(metadata_, input, extensionRegistry);  break;
              }
              case 42: {
                String s = input.readStringRequireUtf8();

                imageType_ = s;
                break;
              }
              case 50: {
                if (!labels_.isMutable()) {
                  labels_ = labels_.mutableCopy();
                }
                LabelsDefaultEntryHolder.defaultEntry.parseInto(labels_, input, extensionRegistry);  break;
              }
              case 56: {

                localSsdCount_ = input.readInt32();
                break;
              }
              case 66: {
                String s = input.readStringRequireUtf8();
                if (!tags_.isModifiable()) {
                  tags_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(tags_);
                }
                tags_.add(s);
                break;
              }
              case 74: {
                String s = input.readStringRequireUtf8();

                serviceAccount_ = s;
                break;
              }
              case 80: {

                preemptible_ = input.readBool();
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (com.google.container.v1.NodeConfig.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.container.v1.NodeConfig)
  private static final com.google.container.v1.NodeConfig DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new NodeConfig();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static com.google.container.v1.NodeConfig getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<NodeConfig> PARSER;

  public static com.google.protobuf.Parser<NodeConfig> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

