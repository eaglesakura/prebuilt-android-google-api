// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/servicecontrol/v1/distribution.proto

package com.google.api.servicecontrol.v1;

/**
 * <pre>
 * Distribution represents a frequency distribution of double-valued sample
 * points. It contains the size of the population of sample points plus
 * additional optional information:
 *   - the arithmetic mean of the samples
 *   - the minimum and maximum of the samples
 *   - the sum-squared-deviation of the samples, used to compute variance
 *   - a histogram of the values of the sample points
 * </pre>
 *
 * Protobuf type {@code google.api.servicecontrol.v1.Distribution}
 */
public  final class Distribution extends
    com.google.protobuf.GeneratedMessageLite<
        Distribution, Distribution.Builder> implements
    // @@protoc_insertion_point(message_implements:google.api.servicecontrol.v1.Distribution)
    DistributionOrBuilder {
  private Distribution() {
    bucketCounts_ = emptyLongList();
  }
  public interface LinearBucketsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.api.servicecontrol.v1.Distribution.LinearBuckets)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    int getNumFiniteBuckets();

    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * Must be strictly positive.
     * </pre>
     *
     * <code>optional double width = 2;</code>
     */
    double getWidth();

    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * </pre>
     *
     * <code>optional double offset = 3;</code>
     */
    double getOffset();
  }
  /**
   * <pre>
   * Describing buckets with constant width.
   * </pre>
   *
   * Protobuf type {@code google.api.servicecontrol.v1.Distribution.LinearBuckets}
   */
  public  static final class LinearBuckets extends
      com.google.protobuf.GeneratedMessageLite<
          LinearBuckets, LinearBuckets.Builder> implements
      // @@protoc_insertion_point(message_implements:google.api.servicecontrol.v1.Distribution.LinearBuckets)
      LinearBucketsOrBuilder {
    private LinearBuckets() {
    }
    public static final int NUM_FINITE_BUCKETS_FIELD_NUMBER = 1;
    private int numFiniteBuckets_;
    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    public int getNumFiniteBuckets() {
      return numFiniteBuckets_;
    }
    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    private void setNumFiniteBuckets(int value) {
      
      numFiniteBuckets_ = value;
    }
    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    private void clearNumFiniteBuckets() {
      
      numFiniteBuckets_ = 0;
    }

    public static final int WIDTH_FIELD_NUMBER = 2;
    private double width_;
    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * Must be strictly positive.
     * </pre>
     *
     * <code>optional double width = 2;</code>
     */
    public double getWidth() {
      return width_;
    }
    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * Must be strictly positive.
     * </pre>
     *
     * <code>optional double width = 2;</code>
     */
    private void setWidth(double value) {
      
      width_ = value;
    }
    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * Must be strictly positive.
     * </pre>
     *
     * <code>optional double width = 2;</code>
     */
    private void clearWidth() {
      
      width_ = 0D;
    }

    public static final int OFFSET_FIELD_NUMBER = 3;
    private double offset_;
    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * </pre>
     *
     * <code>optional double offset = 3;</code>
     */
    public double getOffset() {
      return offset_;
    }
    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * </pre>
     *
     * <code>optional double offset = 3;</code>
     */
    private void setOffset(double value) {
      
      offset_ = value;
    }
    /**
     * <pre>
     * The i'th linear bucket covers the interval
     *   [offset + (i-1) * width, offset + i * width)
     * where i ranges from 1 to num_finite_buckets, inclusive.
     * </pre>
     *
     * <code>optional double offset = 3;</code>
     */
    private void clearOffset() {
      
      offset_ = 0D;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (numFiniteBuckets_ != 0) {
        output.writeInt32(1, numFiniteBuckets_);
      }
      if (width_ != 0D) {
        output.writeDouble(2, width_);
      }
      if (offset_ != 0D) {
        output.writeDouble(3, offset_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (numFiniteBuckets_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, numFiniteBuckets_);
      }
      if (width_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(2, width_);
      }
      if (offset_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(3, offset_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.api.servicecontrol.v1.Distribution.LinearBuckets prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Describing buckets with constant width.
     * </pre>
     *
     * Protobuf type {@code google.api.servicecontrol.v1.Distribution.LinearBuckets}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.api.servicecontrol.v1.Distribution.LinearBuckets, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.api.servicecontrol.v1.Distribution.LinearBuckets)
        com.google.api.servicecontrol.v1.Distribution.LinearBucketsOrBuilder {
      // Construct using com.google.api.servicecontrol.v1.Distribution.LinearBuckets.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The number of finite buckets. With the underflow and overflow buckets,
       * the total number of buckets is `num_finite_buckets` + 2.
       * See comments on `bucket_options` for details.
       * </pre>
       *
       * <code>optional int32 num_finite_buckets = 1;</code>
       */
      public int getNumFiniteBuckets() {
        return instance.getNumFiniteBuckets();
      }
      /**
       * <pre>
       * The number of finite buckets. With the underflow and overflow buckets,
       * the total number of buckets is `num_finite_buckets` + 2.
       * See comments on `bucket_options` for details.
       * </pre>
       *
       * <code>optional int32 num_finite_buckets = 1;</code>
       */
      public Builder setNumFiniteBuckets(int value) {
        copyOnWrite();
        instance.setNumFiniteBuckets(value);
        return this;
      }
      /**
       * <pre>
       * The number of finite buckets. With the underflow and overflow buckets,
       * the total number of buckets is `num_finite_buckets` + 2.
       * See comments on `bucket_options` for details.
       * </pre>
       *
       * <code>optional int32 num_finite_buckets = 1;</code>
       */
      public Builder clearNumFiniteBuckets() {
        copyOnWrite();
        instance.clearNumFiniteBuckets();
        return this;
      }

      /**
       * <pre>
       * The i'th linear bucket covers the interval
       *   [offset + (i-1) * width, offset + i * width)
       * where i ranges from 1 to num_finite_buckets, inclusive.
       * Must be strictly positive.
       * </pre>
       *
       * <code>optional double width = 2;</code>
       */
      public double getWidth() {
        return instance.getWidth();
      }
      /**
       * <pre>
       * The i'th linear bucket covers the interval
       *   [offset + (i-1) * width, offset + i * width)
       * where i ranges from 1 to num_finite_buckets, inclusive.
       * Must be strictly positive.
       * </pre>
       *
       * <code>optional double width = 2;</code>
       */
      public Builder setWidth(double value) {
        copyOnWrite();
        instance.setWidth(value);
        return this;
      }
      /**
       * <pre>
       * The i'th linear bucket covers the interval
       *   [offset + (i-1) * width, offset + i * width)
       * where i ranges from 1 to num_finite_buckets, inclusive.
       * Must be strictly positive.
       * </pre>
       *
       * <code>optional double width = 2;</code>
       */
      public Builder clearWidth() {
        copyOnWrite();
        instance.clearWidth();
        return this;
      }

      /**
       * <pre>
       * The i'th linear bucket covers the interval
       *   [offset + (i-1) * width, offset + i * width)
       * where i ranges from 1 to num_finite_buckets, inclusive.
       * </pre>
       *
       * <code>optional double offset = 3;</code>
       */
      public double getOffset() {
        return instance.getOffset();
      }
      /**
       * <pre>
       * The i'th linear bucket covers the interval
       *   [offset + (i-1) * width, offset + i * width)
       * where i ranges from 1 to num_finite_buckets, inclusive.
       * </pre>
       *
       * <code>optional double offset = 3;</code>
       */
      public Builder setOffset(double value) {
        copyOnWrite();
        instance.setOffset(value);
        return this;
      }
      /**
       * <pre>
       * The i'th linear bucket covers the interval
       *   [offset + (i-1) * width, offset + i * width)
       * where i ranges from 1 to num_finite_buckets, inclusive.
       * </pre>
       *
       * <code>optional double offset = 3;</code>
       */
      public Builder clearOffset() {
        copyOnWrite();
        instance.clearOffset();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.api.servicecontrol.v1.Distribution.LinearBuckets)
    }
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.api.servicecontrol.v1.Distribution.LinearBuckets();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.api.servicecontrol.v1.Distribution.LinearBuckets other = (com.google.api.servicecontrol.v1.Distribution.LinearBuckets) arg1;
          numFiniteBuckets_ = visitor.visitInt(numFiniteBuckets_ != 0, numFiniteBuckets_,
              other.numFiniteBuckets_ != 0, other.numFiniteBuckets_);
          width_ = visitor.visitDouble(width_ != 0D, width_,
              other.width_ != 0D, other.width_);
          offset_ = visitor.visitDouble(offset_ != 0D, offset_,
              other.offset_ != 0D, other.offset_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 8: {

                  numFiniteBuckets_ = input.readInt32();
                  break;
                }
                case 17: {

                  width_ = input.readDouble();
                  break;
                }
                case 25: {

                  offset_ = input.readDouble();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.api.servicecontrol.v1.Distribution.LinearBuckets.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.api.servicecontrol.v1.Distribution.LinearBuckets)
    private static final com.google.api.servicecontrol.v1.Distribution.LinearBuckets DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new LinearBuckets();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.api.servicecontrol.v1.Distribution.LinearBuckets getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<LinearBuckets> PARSER;

    public static com.google.protobuf.Parser<LinearBuckets> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExponentialBucketsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.api.servicecontrol.v1.Distribution.ExponentialBuckets)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    int getNumFiniteBuckets();

    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be larger than 1.0.
     * </pre>
     *
     * <code>optional double growth_factor = 2;</code>
     */
    double getGrowthFactor();

    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be &gt; 0.
     * </pre>
     *
     * <code>optional double scale = 3;</code>
     */
    double getScale();
  }
  /**
   * <pre>
   * Describing buckets with exponentially growing width.
   * </pre>
   *
   * Protobuf type {@code google.api.servicecontrol.v1.Distribution.ExponentialBuckets}
   */
  public  static final class ExponentialBuckets extends
      com.google.protobuf.GeneratedMessageLite<
          ExponentialBuckets, ExponentialBuckets.Builder> implements
      // @@protoc_insertion_point(message_implements:google.api.servicecontrol.v1.Distribution.ExponentialBuckets)
      ExponentialBucketsOrBuilder {
    private ExponentialBuckets() {
    }
    public static final int NUM_FINITE_BUCKETS_FIELD_NUMBER = 1;
    private int numFiniteBuckets_;
    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    public int getNumFiniteBuckets() {
      return numFiniteBuckets_;
    }
    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    private void setNumFiniteBuckets(int value) {
      
      numFiniteBuckets_ = value;
    }
    /**
     * <pre>
     * The number of finite buckets. With the underflow and overflow buckets,
     * the total number of buckets is `num_finite_buckets` + 2.
     * See comments on `bucket_options` for details.
     * </pre>
     *
     * <code>optional int32 num_finite_buckets = 1;</code>
     */
    private void clearNumFiniteBuckets() {
      
      numFiniteBuckets_ = 0;
    }

    public static final int GROWTH_FACTOR_FIELD_NUMBER = 2;
    private double growthFactor_;
    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be larger than 1.0.
     * </pre>
     *
     * <code>optional double growth_factor = 2;</code>
     */
    public double getGrowthFactor() {
      return growthFactor_;
    }
    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be larger than 1.0.
     * </pre>
     *
     * <code>optional double growth_factor = 2;</code>
     */
    private void setGrowthFactor(double value) {
      
      growthFactor_ = value;
    }
    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be larger than 1.0.
     * </pre>
     *
     * <code>optional double growth_factor = 2;</code>
     */
    private void clearGrowthFactor() {
      
      growthFactor_ = 0D;
    }

    public static final int SCALE_FIELD_NUMBER = 3;
    private double scale_;
    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be &gt; 0.
     * </pre>
     *
     * <code>optional double scale = 3;</code>
     */
    public double getScale() {
      return scale_;
    }
    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be &gt; 0.
     * </pre>
     *
     * <code>optional double scale = 3;</code>
     */
    private void setScale(double value) {
      
      scale_ = value;
    }
    /**
     * <pre>
     * The i'th exponential bucket covers the interval
     *   [scale * growth_factor^(i-1), scale * growth_factor^i)
     * where i ranges from 1 to num_finite_buckets inclusive.
     * Must be &gt; 0.
     * </pre>
     *
     * <code>optional double scale = 3;</code>
     */
    private void clearScale() {
      
      scale_ = 0D;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (numFiniteBuckets_ != 0) {
        output.writeInt32(1, numFiniteBuckets_);
      }
      if (growthFactor_ != 0D) {
        output.writeDouble(2, growthFactor_);
      }
      if (scale_ != 0D) {
        output.writeDouble(3, scale_);
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      if (numFiniteBuckets_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, numFiniteBuckets_);
      }
      if (growthFactor_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(2, growthFactor_);
      }
      if (scale_ != 0D) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(3, scale_);
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Describing buckets with exponentially growing width.
     * </pre>
     *
     * Protobuf type {@code google.api.servicecontrol.v1.Distribution.ExponentialBuckets}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.api.servicecontrol.v1.Distribution.ExponentialBuckets)
        com.google.api.servicecontrol.v1.Distribution.ExponentialBucketsOrBuilder {
      // Construct using com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The number of finite buckets. With the underflow and overflow buckets,
       * the total number of buckets is `num_finite_buckets` + 2.
       * See comments on `bucket_options` for details.
       * </pre>
       *
       * <code>optional int32 num_finite_buckets = 1;</code>
       */
      public int getNumFiniteBuckets() {
        return instance.getNumFiniteBuckets();
      }
      /**
       * <pre>
       * The number of finite buckets. With the underflow and overflow buckets,
       * the total number of buckets is `num_finite_buckets` + 2.
       * See comments on `bucket_options` for details.
       * </pre>
       *
       * <code>optional int32 num_finite_buckets = 1;</code>
       */
      public Builder setNumFiniteBuckets(int value) {
        copyOnWrite();
        instance.setNumFiniteBuckets(value);
        return this;
      }
      /**
       * <pre>
       * The number of finite buckets. With the underflow and overflow buckets,
       * the total number of buckets is `num_finite_buckets` + 2.
       * See comments on `bucket_options` for details.
       * </pre>
       *
       * <code>optional int32 num_finite_buckets = 1;</code>
       */
      public Builder clearNumFiniteBuckets() {
        copyOnWrite();
        instance.clearNumFiniteBuckets();
        return this;
      }

      /**
       * <pre>
       * The i'th exponential bucket covers the interval
       *   [scale * growth_factor^(i-1), scale * growth_factor^i)
       * where i ranges from 1 to num_finite_buckets inclusive.
       * Must be larger than 1.0.
       * </pre>
       *
       * <code>optional double growth_factor = 2;</code>
       */
      public double getGrowthFactor() {
        return instance.getGrowthFactor();
      }
      /**
       * <pre>
       * The i'th exponential bucket covers the interval
       *   [scale * growth_factor^(i-1), scale * growth_factor^i)
       * where i ranges from 1 to num_finite_buckets inclusive.
       * Must be larger than 1.0.
       * </pre>
       *
       * <code>optional double growth_factor = 2;</code>
       */
      public Builder setGrowthFactor(double value) {
        copyOnWrite();
        instance.setGrowthFactor(value);
        return this;
      }
      /**
       * <pre>
       * The i'th exponential bucket covers the interval
       *   [scale * growth_factor^(i-1), scale * growth_factor^i)
       * where i ranges from 1 to num_finite_buckets inclusive.
       * Must be larger than 1.0.
       * </pre>
       *
       * <code>optional double growth_factor = 2;</code>
       */
      public Builder clearGrowthFactor() {
        copyOnWrite();
        instance.clearGrowthFactor();
        return this;
      }

      /**
       * <pre>
       * The i'th exponential bucket covers the interval
       *   [scale * growth_factor^(i-1), scale * growth_factor^i)
       * where i ranges from 1 to num_finite_buckets inclusive.
       * Must be &gt; 0.
       * </pre>
       *
       * <code>optional double scale = 3;</code>
       */
      public double getScale() {
        return instance.getScale();
      }
      /**
       * <pre>
       * The i'th exponential bucket covers the interval
       *   [scale * growth_factor^(i-1), scale * growth_factor^i)
       * where i ranges from 1 to num_finite_buckets inclusive.
       * Must be &gt; 0.
       * </pre>
       *
       * <code>optional double scale = 3;</code>
       */
      public Builder setScale(double value) {
        copyOnWrite();
        instance.setScale(value);
        return this;
      }
      /**
       * <pre>
       * The i'th exponential bucket covers the interval
       *   [scale * growth_factor^(i-1), scale * growth_factor^i)
       * where i ranges from 1 to num_finite_buckets inclusive.
       * Must be &gt; 0.
       * </pre>
       *
       * <code>optional double scale = 3;</code>
       */
      public Builder clearScale() {
        copyOnWrite();
        instance.clearScale();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.api.servicecontrol.v1.Distribution.ExponentialBuckets)
    }
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets other = (com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) arg1;
          numFiniteBuckets_ = visitor.visitInt(numFiniteBuckets_ != 0, numFiniteBuckets_,
              other.numFiniteBuckets_ != 0, other.numFiniteBuckets_);
          growthFactor_ = visitor.visitDouble(growthFactor_ != 0D, growthFactor_,
              other.growthFactor_ != 0D, other.growthFactor_);
          scale_ = visitor.visitDouble(scale_ != 0D, scale_,
              other.scale_ != 0D, other.scale_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 8: {

                  numFiniteBuckets_ = input.readInt32();
                  break;
                }
                case 17: {

                  growthFactor_ = input.readDouble();
                  break;
                }
                case 25: {

                  scale_ = input.readDouble();
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.api.servicecontrol.v1.Distribution.ExponentialBuckets)
    private static final com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ExponentialBuckets();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ExponentialBuckets> PARSER;

    public static com.google.protobuf.Parser<ExponentialBuckets> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ExplicitBucketsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:google.api.servicecontrol.v1.Distribution.ExplicitBuckets)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    java.util.List<java.lang.Double> getBoundsList();
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    int getBoundsCount();
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    double getBounds(int index);
  }
  /**
   * <pre>
   * Describing buckets with arbitrary user-provided width.
   * </pre>
   *
   * Protobuf type {@code google.api.servicecontrol.v1.Distribution.ExplicitBuckets}
   */
  public  static final class ExplicitBuckets extends
      com.google.protobuf.GeneratedMessageLite<
          ExplicitBuckets, ExplicitBuckets.Builder> implements
      // @@protoc_insertion_point(message_implements:google.api.servicecontrol.v1.Distribution.ExplicitBuckets)
      ExplicitBucketsOrBuilder {
    private ExplicitBuckets() {
      bounds_ = emptyDoubleList();
    }
    public static final int BOUNDS_FIELD_NUMBER = 1;
    private com.google.protobuf.Internal.DoubleList bounds_;
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    public java.util.List<java.lang.Double>
        getBoundsList() {
      return bounds_;
    }
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    public int getBoundsCount() {
      return bounds_.size();
    }
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    public double getBounds(int index) {
      return bounds_.getDouble(index);
    }
    private void ensureBoundsIsMutable() {
      if (!bounds_.isModifiable()) {
        bounds_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(bounds_);
       }
    }
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    private void setBounds(
        int index, double value) {
      ensureBoundsIsMutable();
      bounds_.setDouble(index, value);
    }
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    private void addBounds(double value) {
      ensureBoundsIsMutable();
      bounds_.addDouble(value);
    }
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    private void addAllBounds(
        java.lang.Iterable<? extends java.lang.Double> values) {
      ensureBoundsIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, bounds_);
    }
    /**
     * <pre>
     * 'bound' is a list of strictly increasing boundaries between
     * buckets. Note that a list of length N-1 defines N buckets because
     * of fenceposting. See comments on `bucket_options` for details.
     * The i'th finite bucket covers the interval
     *   [bound[i-1], bound[i])
     * where i ranges from 1 to bound_size() - 1. Note that there are no
     * finite buckets at all if 'bound' only contains a single element; in
     * that special case the single bound defines the boundary between the
     * underflow and overflow buckets.
     * bucket number                   lower bound    upper bound
     *  i == 0 (underflow)              -inf           bound[i]
     *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
     *  i == bound_size() (overflow)    bound[i-1]     +inf
     * </pre>
     *
     * <code>repeated double bounds = 1;</code>
     */
    private void clearBounds() {
      bounds_ = emptyDoubleList();
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      getSerializedSize();
      for (int i = 0; i < bounds_.size(); i++) {
        output.writeDouble(1, bounds_.getDouble(i));
      }
    }

    public int getSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        dataSize = 8 * getBoundsList().size();
        size += dataSize;
        size += 1 * getBoundsList().size();
      }
      memoizedSerializedSize = size;
      return size;
    }

    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }

    /**
     * <pre>
     * Describing buckets with arbitrary user-provided width.
     * </pre>
     *
     * Protobuf type {@code google.api.servicecontrol.v1.Distribution.ExplicitBuckets}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets, Builder> implements
        // @@protoc_insertion_point(builder_implements:google.api.servicecontrol.v1.Distribution.ExplicitBuckets)
        com.google.api.servicecontrol.v1.Distribution.ExplicitBucketsOrBuilder {
      // Construct using com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public java.util.List<java.lang.Double>
          getBoundsList() {
        return java.util.Collections.unmodifiableList(
            instance.getBoundsList());
      }
      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public int getBoundsCount() {
        return instance.getBoundsCount();
      }
      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public double getBounds(int index) {
        return instance.getBounds(index);
      }
      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public Builder setBounds(
          int index, double value) {
        copyOnWrite();
        instance.setBounds(index, value);
        return this;
      }
      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public Builder addBounds(double value) {
        copyOnWrite();
        instance.addBounds(value);
        return this;
      }
      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public Builder addAllBounds(
          java.lang.Iterable<? extends java.lang.Double> values) {
        copyOnWrite();
        instance.addAllBounds(values);
        return this;
      }
      /**
       * <pre>
       * 'bound' is a list of strictly increasing boundaries between
       * buckets. Note that a list of length N-1 defines N buckets because
       * of fenceposting. See comments on `bucket_options` for details.
       * The i'th finite bucket covers the interval
       *   [bound[i-1], bound[i])
       * where i ranges from 1 to bound_size() - 1. Note that there are no
       * finite buckets at all if 'bound' only contains a single element; in
       * that special case the single bound defines the boundary between the
       * underflow and overflow buckets.
       * bucket number                   lower bound    upper bound
       *  i == 0 (underflow)              -inf           bound[i]
       *  0 &lt; i &lt; bound_size()            bound[i-1]     bound[i]
       *  i == bound_size() (overflow)    bound[i-1]     +inf
       * </pre>
       *
       * <code>repeated double bounds = 1;</code>
       */
      public Builder clearBounds() {
        copyOnWrite();
        instance.clearBounds();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:google.api.servicecontrol.v1.Distribution.ExplicitBuckets)
    }
    protected final Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        Object arg0, Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets();
        }
        case IS_INITIALIZED: {
          return DEFAULT_INSTANCE;
        }
        case MAKE_IMMUTABLE: {
          bounds_.makeImmutable();
          return null;
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case VISIT: {
          Visitor visitor = (Visitor) arg0;
          com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets other = (com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) arg1;
          bounds_= visitor.visitDoubleList(bounds_, other.bounds_);
          if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
              .INSTANCE) {
          }
          return this;
        }
        case MERGE_FROM_STREAM: {
          com.google.protobuf.CodedInputStream input =
              (com.google.protobuf.CodedInputStream) arg0;
          com.google.protobuf.ExtensionRegistryLite extensionRegistry =
              (com.google.protobuf.ExtensionRegistryLite) arg1;
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                default: {
                  if (!input.skipField(tag)) {
                    done = true;
                  }
                  break;
                }
                case 9: {
                  if (!bounds_.isModifiable()) {
                    bounds_ =
                        com.google.protobuf.GeneratedMessageLite.mutableCopy(bounds_);
                  }
                  bounds_.addDouble(input.readDouble());
                  break;
                }
                case 10: {
                  int length = input.readRawVarint32();
                  int limit = input.pushLimit(length);
                  if (!bounds_.isModifiable() && input.getBytesUntilLimit() > 0) {
                    final int currentSize = bounds_.size();
                    bounds_ = bounds_.mutableCopyWithCapacity(
                        currentSize + (length/8));
                  }
                  while (input.getBytesUntilLimit() > 0) {
                    bounds_.addDouble(input.readDouble());
                  }
                  input.popLimit(limit);
                  break;
                }
              }
            }
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw new RuntimeException(e.setUnfinishedMessage(this));
          } catch (java.io.IOException e) {
            throw new RuntimeException(
                new com.google.protobuf.InvalidProtocolBufferException(
                    e.getMessage()).setUnfinishedMessage(this));
          } finally {
          }
        }
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          if (PARSER == null) {    synchronized (com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.class) {
              if (PARSER == null) {
                PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
              }
            }
          }
          return PARSER;
        }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:google.api.servicecontrol.v1.Distribution.ExplicitBuckets)
    private static final com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ExplicitBuckets();
      DEFAULT_INSTANCE.makeImmutable();
    }

    public static com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ExplicitBuckets> PARSER;

    public static com.google.protobuf.Parser<ExplicitBuckets> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  private int bitField0_;
  private int bucketOptionCase_ = 0;
  private java.lang.Object bucketOption_;
  public enum BucketOptionCase
      implements com.google.protobuf.Internal.EnumLite {
    LINEAR_BUCKETS(7),
    EXPONENTIAL_BUCKETS(8),
    EXPLICIT_BUCKETS(9),
    BUCKETOPTION_NOT_SET(0);
    private final int value;
    private BucketOptionCase(int value) {
      this.value = value;
    }
    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static BucketOptionCase valueOf(int value) {
      return forNumber(value);
    }

    public static BucketOptionCase forNumber(int value) {
      switch (value) {
        case 7: return LINEAR_BUCKETS;
        case 8: return EXPONENTIAL_BUCKETS;
        case 9: return EXPLICIT_BUCKETS;
        case 0: return BUCKETOPTION_NOT_SET;
        default: return null;
      }
    }
    public int getNumber() {
      return this.value;
    }
  };

  public BucketOptionCase
  getBucketOptionCase() {
    return BucketOptionCase.forNumber(
        bucketOptionCase_);
  }

  private void clearBucketOption() {
    bucketOptionCase_ = 0;
    bucketOption_ = null;
  }

  public static final int COUNT_FIELD_NUMBER = 1;
  private long count_;
  /**
   * <pre>
   * The total number of samples in the distribution. Must be &gt;= 0.
   * </pre>
   *
   * <code>optional int64 count = 1;</code>
   */
  public long getCount() {
    return count_;
  }
  /**
   * <pre>
   * The total number of samples in the distribution. Must be &gt;= 0.
   * </pre>
   *
   * <code>optional int64 count = 1;</code>
   */
  private void setCount(long value) {
    
    count_ = value;
  }
  /**
   * <pre>
   * The total number of samples in the distribution. Must be &gt;= 0.
   * </pre>
   *
   * <code>optional int64 count = 1;</code>
   */
  private void clearCount() {
    
    count_ = 0L;
  }

  public static final int MEAN_FIELD_NUMBER = 2;
  private double mean_;
  /**
   * <pre>
   * The arithmetic mean of the samples in the distribution. If `count` is
   * zero then this field must be zero.
   * </pre>
   *
   * <code>optional double mean = 2;</code>
   */
  public double getMean() {
    return mean_;
  }
  /**
   * <pre>
   * The arithmetic mean of the samples in the distribution. If `count` is
   * zero then this field must be zero.
   * </pre>
   *
   * <code>optional double mean = 2;</code>
   */
  private void setMean(double value) {
    
    mean_ = value;
  }
  /**
   * <pre>
   * The arithmetic mean of the samples in the distribution. If `count` is
   * zero then this field must be zero.
   * </pre>
   *
   * <code>optional double mean = 2;</code>
   */
  private void clearMean() {
    
    mean_ = 0D;
  }

  public static final int MINIMUM_FIELD_NUMBER = 3;
  private double minimum_;
  /**
   * <pre>
   * The minimum of the population of values. Ignored if `count` is zero.
   * </pre>
   *
   * <code>optional double minimum = 3;</code>
   */
  public double getMinimum() {
    return minimum_;
  }
  /**
   * <pre>
   * The minimum of the population of values. Ignored if `count` is zero.
   * </pre>
   *
   * <code>optional double minimum = 3;</code>
   */
  private void setMinimum(double value) {
    
    minimum_ = value;
  }
  /**
   * <pre>
   * The minimum of the population of values. Ignored if `count` is zero.
   * </pre>
   *
   * <code>optional double minimum = 3;</code>
   */
  private void clearMinimum() {
    
    minimum_ = 0D;
  }

  public static final int MAXIMUM_FIELD_NUMBER = 4;
  private double maximum_;
  /**
   * <pre>
   * The maximum of the population of values. Ignored if `count` is zero.
   * </pre>
   *
   * <code>optional double maximum = 4;</code>
   */
  public double getMaximum() {
    return maximum_;
  }
  /**
   * <pre>
   * The maximum of the population of values. Ignored if `count` is zero.
   * </pre>
   *
   * <code>optional double maximum = 4;</code>
   */
  private void setMaximum(double value) {
    
    maximum_ = value;
  }
  /**
   * <pre>
   * The maximum of the population of values. Ignored if `count` is zero.
   * </pre>
   *
   * <code>optional double maximum = 4;</code>
   */
  private void clearMaximum() {
    
    maximum_ = 0D;
  }

  public static final int SUM_OF_SQUARED_DEVIATION_FIELD_NUMBER = 5;
  private double sumOfSquaredDeviation_;
  /**
   * <pre>
   * The sum of squared deviations from the mean:
   *   Sum[i=1..count]((x_i - mean)^2)
   * where each x_i is a sample values. If `count` is zero then this field
   * must be zero, otherwise validation of the request fails.
   * </pre>
   *
   * <code>optional double sum_of_squared_deviation = 5;</code>
   */
  public double getSumOfSquaredDeviation() {
    return sumOfSquaredDeviation_;
  }
  /**
   * <pre>
   * The sum of squared deviations from the mean:
   *   Sum[i=1..count]((x_i - mean)^2)
   * where each x_i is a sample values. If `count` is zero then this field
   * must be zero, otherwise validation of the request fails.
   * </pre>
   *
   * <code>optional double sum_of_squared_deviation = 5;</code>
   */
  private void setSumOfSquaredDeviation(double value) {
    
    sumOfSquaredDeviation_ = value;
  }
  /**
   * <pre>
   * The sum of squared deviations from the mean:
   *   Sum[i=1..count]((x_i - mean)^2)
   * where each x_i is a sample values. If `count` is zero then this field
   * must be zero, otherwise validation of the request fails.
   * </pre>
   *
   * <code>optional double sum_of_squared_deviation = 5;</code>
   */
  private void clearSumOfSquaredDeviation() {
    
    sumOfSquaredDeviation_ = 0D;
  }

  public static final int BUCKET_COUNTS_FIELD_NUMBER = 6;
  private com.google.protobuf.Internal.LongList bucketCounts_;
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  public java.util.List<java.lang.Long>
      getBucketCountsList() {
    return bucketCounts_;
  }
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  public int getBucketCountsCount() {
    return bucketCounts_.size();
  }
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  public long getBucketCounts(int index) {
    return bucketCounts_.getLong(index);
  }
  private void ensureBucketCountsIsMutable() {
    if (!bucketCounts_.isModifiable()) {
      bucketCounts_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(bucketCounts_);
     }
  }
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  private void setBucketCounts(
      int index, long value) {
    ensureBucketCountsIsMutable();
    bucketCounts_.setLong(index, value);
  }
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  private void addBucketCounts(long value) {
    ensureBucketCountsIsMutable();
    bucketCounts_.addLong(value);
  }
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  private void addAllBucketCounts(
      java.lang.Iterable<? extends java.lang.Long> values) {
    ensureBucketCountsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, bucketCounts_);
  }
  /**
   * <pre>
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   * Any suffix of trailing zeros may be omitted.
   * </pre>
   *
   * <code>repeated int64 bucket_counts = 6;</code>
   */
  private void clearBucketCounts() {
    bucketCounts_ = emptyLongList();
  }

  public static final int LINEAR_BUCKETS_FIELD_NUMBER = 7;
  /**
   * <pre>
   * Buckets with constant width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
   */
  public com.google.api.servicecontrol.v1.Distribution.LinearBuckets getLinearBuckets() {
    if (bucketOptionCase_ == 7) {
       return (com.google.api.servicecontrol.v1.Distribution.LinearBuckets) bucketOption_;
    }
    return com.google.api.servicecontrol.v1.Distribution.LinearBuckets.getDefaultInstance();
  }
  /**
   * <pre>
   * Buckets with constant width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
   */
  private void setLinearBuckets(com.google.api.servicecontrol.v1.Distribution.LinearBuckets value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bucketOption_ = value;
    bucketOptionCase_ = 7;
  }
  /**
   * <pre>
   * Buckets with constant width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
   */
  private void setLinearBuckets(
      com.google.api.servicecontrol.v1.Distribution.LinearBuckets.Builder builderForValue) {
    bucketOption_ = builderForValue.build();
    bucketOptionCase_ = 7;
  }
  /**
   * <pre>
   * Buckets with constant width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
   */
  private void mergeLinearBuckets(com.google.api.servicecontrol.v1.Distribution.LinearBuckets value) {
    if (bucketOptionCase_ == 7 &&
        bucketOption_ != com.google.api.servicecontrol.v1.Distribution.LinearBuckets.getDefaultInstance()) {
      bucketOption_ = com.google.api.servicecontrol.v1.Distribution.LinearBuckets.newBuilder((com.google.api.servicecontrol.v1.Distribution.LinearBuckets) bucketOption_)
          .mergeFrom(value).buildPartial();
    } else {
      bucketOption_ = value;
    }
    bucketOptionCase_ = 7;
  }
  /**
   * <pre>
   * Buckets with constant width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
   */
  private void clearLinearBuckets() {
    if (bucketOptionCase_ == 7) {
      bucketOptionCase_ = 0;
      bucketOption_ = null;
    }
  }

  public static final int EXPONENTIAL_BUCKETS_FIELD_NUMBER = 8;
  /**
   * <pre>
   * Buckets with exponentially growing width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
   */
  public com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets getExponentialBuckets() {
    if (bucketOptionCase_ == 8) {
       return (com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) bucketOption_;
    }
    return com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.getDefaultInstance();
  }
  /**
   * <pre>
   * Buckets with exponentially growing width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
   */
  private void setExponentialBuckets(com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bucketOption_ = value;
    bucketOptionCase_ = 8;
  }
  /**
   * <pre>
   * Buckets with exponentially growing width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
   */
  private void setExponentialBuckets(
      com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.Builder builderForValue) {
    bucketOption_ = builderForValue.build();
    bucketOptionCase_ = 8;
  }
  /**
   * <pre>
   * Buckets with exponentially growing width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
   */
  private void mergeExponentialBuckets(com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets value) {
    if (bucketOptionCase_ == 8 &&
        bucketOption_ != com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.getDefaultInstance()) {
      bucketOption_ = com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.newBuilder((com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) bucketOption_)
          .mergeFrom(value).buildPartial();
    } else {
      bucketOption_ = value;
    }
    bucketOptionCase_ = 8;
  }
  /**
   * <pre>
   * Buckets with exponentially growing width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
   */
  private void clearExponentialBuckets() {
    if (bucketOptionCase_ == 8) {
      bucketOptionCase_ = 0;
      bucketOption_ = null;
    }
  }

  public static final int EXPLICIT_BUCKETS_FIELD_NUMBER = 9;
  /**
   * <pre>
   * Buckets with arbitrary user-provided width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
   */
  public com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets getExplicitBuckets() {
    if (bucketOptionCase_ == 9) {
       return (com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) bucketOption_;
    }
    return com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.getDefaultInstance();
  }
  /**
   * <pre>
   * Buckets with arbitrary user-provided width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
   */
  private void setExplicitBuckets(com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bucketOption_ = value;
    bucketOptionCase_ = 9;
  }
  /**
   * <pre>
   * Buckets with arbitrary user-provided width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
   */
  private void setExplicitBuckets(
      com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.Builder builderForValue) {
    bucketOption_ = builderForValue.build();
    bucketOptionCase_ = 9;
  }
  /**
   * <pre>
   * Buckets with arbitrary user-provided width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
   */
  private void mergeExplicitBuckets(com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets value) {
    if (bucketOptionCase_ == 9 &&
        bucketOption_ != com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.getDefaultInstance()) {
      bucketOption_ = com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.newBuilder((com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) bucketOption_)
          .mergeFrom(value).buildPartial();
    } else {
      bucketOption_ = value;
    }
    bucketOptionCase_ = 9;
  }
  /**
   * <pre>
   * Buckets with arbitrary user-provided width.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
   */
  private void clearExplicitBuckets() {
    if (bucketOptionCase_ == 9) {
      bucketOptionCase_ = 0;
      bucketOption_ = null;
    }
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    getSerializedSize();
    if (count_ != 0L) {
      output.writeInt64(1, count_);
    }
    if (mean_ != 0D) {
      output.writeDouble(2, mean_);
    }
    if (minimum_ != 0D) {
      output.writeDouble(3, minimum_);
    }
    if (maximum_ != 0D) {
      output.writeDouble(4, maximum_);
    }
    if (sumOfSquaredDeviation_ != 0D) {
      output.writeDouble(5, sumOfSquaredDeviation_);
    }
    for (int i = 0; i < bucketCounts_.size(); i++) {
      output.writeInt64(6, bucketCounts_.getLong(i));
    }
    if (bucketOptionCase_ == 7) {
      output.writeMessage(7, (com.google.api.servicecontrol.v1.Distribution.LinearBuckets) bucketOption_);
    }
    if (bucketOptionCase_ == 8) {
      output.writeMessage(8, (com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) bucketOption_);
    }
    if (bucketOptionCase_ == 9) {
      output.writeMessage(9, (com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) bucketOption_);
    }
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (count_ != 0L) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(1, count_);
    }
    if (mean_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(2, mean_);
    }
    if (minimum_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(3, minimum_);
    }
    if (maximum_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(4, maximum_);
    }
    if (sumOfSquaredDeviation_ != 0D) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(5, sumOfSquaredDeviation_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < bucketCounts_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeInt64SizeNoTag(bucketCounts_.getLong(i));
      }
      size += dataSize;
      size += 1 * getBucketCountsList().size();
    }
    if (bucketOptionCase_ == 7) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, (com.google.api.servicecontrol.v1.Distribution.LinearBuckets) bucketOption_);
    }
    if (bucketOptionCase_ == 8) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, (com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) bucketOption_);
    }
    if (bucketOptionCase_ == 9) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, (com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) bucketOption_);
    }
    memoizedSerializedSize = size;
    return size;
  }

  public static com.google.api.servicecontrol.v1.Distribution parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.servicecontrol.v1.Distribution parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.api.servicecontrol.v1.Distribution prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * Distribution represents a frequency distribution of double-valued sample
   * points. It contains the size of the population of sample points plus
   * additional optional information:
   *   - the arithmetic mean of the samples
   *   - the minimum and maximum of the samples
   *   - the sum-squared-deviation of the samples, used to compute variance
   *   - a histogram of the values of the sample points
   * </pre>
   *
   * Protobuf type {@code google.api.servicecontrol.v1.Distribution}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.api.servicecontrol.v1.Distribution, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.api.servicecontrol.v1.Distribution)
      com.google.api.servicecontrol.v1.DistributionOrBuilder {
    // Construct using com.google.api.servicecontrol.v1.Distribution.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }

    public BucketOptionCase
        getBucketOptionCase() {
      return instance.getBucketOptionCase();
    }

    public Builder clearBucketOption() {
      copyOnWrite();
      instance.clearBucketOption();
      return this;
    }


    /**
     * <pre>
     * The total number of samples in the distribution. Must be &gt;= 0.
     * </pre>
     *
     * <code>optional int64 count = 1;</code>
     */
    public long getCount() {
      return instance.getCount();
    }
    /**
     * <pre>
     * The total number of samples in the distribution. Must be &gt;= 0.
     * </pre>
     *
     * <code>optional int64 count = 1;</code>
     */
    public Builder setCount(long value) {
      copyOnWrite();
      instance.setCount(value);
      return this;
    }
    /**
     * <pre>
     * The total number of samples in the distribution. Must be &gt;= 0.
     * </pre>
     *
     * <code>optional int64 count = 1;</code>
     */
    public Builder clearCount() {
      copyOnWrite();
      instance.clearCount();
      return this;
    }

    /**
     * <pre>
     * The arithmetic mean of the samples in the distribution. If `count` is
     * zero then this field must be zero.
     * </pre>
     *
     * <code>optional double mean = 2;</code>
     */
    public double getMean() {
      return instance.getMean();
    }
    /**
     * <pre>
     * The arithmetic mean of the samples in the distribution. If `count` is
     * zero then this field must be zero.
     * </pre>
     *
     * <code>optional double mean = 2;</code>
     */
    public Builder setMean(double value) {
      copyOnWrite();
      instance.setMean(value);
      return this;
    }
    /**
     * <pre>
     * The arithmetic mean of the samples in the distribution. If `count` is
     * zero then this field must be zero.
     * </pre>
     *
     * <code>optional double mean = 2;</code>
     */
    public Builder clearMean() {
      copyOnWrite();
      instance.clearMean();
      return this;
    }

    /**
     * <pre>
     * The minimum of the population of values. Ignored if `count` is zero.
     * </pre>
     *
     * <code>optional double minimum = 3;</code>
     */
    public double getMinimum() {
      return instance.getMinimum();
    }
    /**
     * <pre>
     * The minimum of the population of values. Ignored if `count` is zero.
     * </pre>
     *
     * <code>optional double minimum = 3;</code>
     */
    public Builder setMinimum(double value) {
      copyOnWrite();
      instance.setMinimum(value);
      return this;
    }
    /**
     * <pre>
     * The minimum of the population of values. Ignored if `count` is zero.
     * </pre>
     *
     * <code>optional double minimum = 3;</code>
     */
    public Builder clearMinimum() {
      copyOnWrite();
      instance.clearMinimum();
      return this;
    }

    /**
     * <pre>
     * The maximum of the population of values. Ignored if `count` is zero.
     * </pre>
     *
     * <code>optional double maximum = 4;</code>
     */
    public double getMaximum() {
      return instance.getMaximum();
    }
    /**
     * <pre>
     * The maximum of the population of values. Ignored if `count` is zero.
     * </pre>
     *
     * <code>optional double maximum = 4;</code>
     */
    public Builder setMaximum(double value) {
      copyOnWrite();
      instance.setMaximum(value);
      return this;
    }
    /**
     * <pre>
     * The maximum of the population of values. Ignored if `count` is zero.
     * </pre>
     *
     * <code>optional double maximum = 4;</code>
     */
    public Builder clearMaximum() {
      copyOnWrite();
      instance.clearMaximum();
      return this;
    }

    /**
     * <pre>
     * The sum of squared deviations from the mean:
     *   Sum[i=1..count]((x_i - mean)^2)
     * where each x_i is a sample values. If `count` is zero then this field
     * must be zero, otherwise validation of the request fails.
     * </pre>
     *
     * <code>optional double sum_of_squared_deviation = 5;</code>
     */
    public double getSumOfSquaredDeviation() {
      return instance.getSumOfSquaredDeviation();
    }
    /**
     * <pre>
     * The sum of squared deviations from the mean:
     *   Sum[i=1..count]((x_i - mean)^2)
     * where each x_i is a sample values. If `count` is zero then this field
     * must be zero, otherwise validation of the request fails.
     * </pre>
     *
     * <code>optional double sum_of_squared_deviation = 5;</code>
     */
    public Builder setSumOfSquaredDeviation(double value) {
      copyOnWrite();
      instance.setSumOfSquaredDeviation(value);
      return this;
    }
    /**
     * <pre>
     * The sum of squared deviations from the mean:
     *   Sum[i=1..count]((x_i - mean)^2)
     * where each x_i is a sample values. If `count` is zero then this field
     * must be zero, otherwise validation of the request fails.
     * </pre>
     *
     * <code>optional double sum_of_squared_deviation = 5;</code>
     */
    public Builder clearSumOfSquaredDeviation() {
      copyOnWrite();
      instance.clearSumOfSquaredDeviation();
      return this;
    }

    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public java.util.List<java.lang.Long>
        getBucketCountsList() {
      return java.util.Collections.unmodifiableList(
          instance.getBucketCountsList());
    }
    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public int getBucketCountsCount() {
      return instance.getBucketCountsCount();
    }
    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public long getBucketCounts(int index) {
      return instance.getBucketCounts(index);
    }
    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public Builder setBucketCounts(
        int index, long value) {
      copyOnWrite();
      instance.setBucketCounts(index, value);
      return this;
    }
    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public Builder addBucketCounts(long value) {
      copyOnWrite();
      instance.addBucketCounts(value);
      return this;
    }
    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public Builder addAllBucketCounts(
        java.lang.Iterable<? extends java.lang.Long> values) {
      copyOnWrite();
      instance.addAllBucketCounts(values);
      return this;
    }
    /**
     * <pre>
     * The number of samples in each histogram bucket. `bucket_counts` are
     * optional. If present, they must sum to the `count` value.
     * The buckets are defined below in `bucket_option`. There are N buckets.
     * `bucket_counts[0]` is the number of samples in the underflow bucket.
     * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
     * in each of the finite buckets. And `bucket_counts[N] is the number
     * of samples in the overflow bucket. See the comments of `bucket_option`
     * below for more details.
     * Any suffix of trailing zeros may be omitted.
     * </pre>
     *
     * <code>repeated int64 bucket_counts = 6;</code>
     */
    public Builder clearBucketCounts() {
      copyOnWrite();
      instance.clearBucketCounts();
      return this;
    }

    /**
     * <pre>
     * Buckets with constant width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
     */
    public com.google.api.servicecontrol.v1.Distribution.LinearBuckets getLinearBuckets() {
      return instance.getLinearBuckets();
    }
    /**
     * <pre>
     * Buckets with constant width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
     */
    public Builder setLinearBuckets(com.google.api.servicecontrol.v1.Distribution.LinearBuckets value) {
      copyOnWrite();
      instance.setLinearBuckets(value);
      return this;
    }
    /**
     * <pre>
     * Buckets with constant width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
     */
    public Builder setLinearBuckets(
        com.google.api.servicecontrol.v1.Distribution.LinearBuckets.Builder builderForValue) {
      copyOnWrite();
      instance.setLinearBuckets(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Buckets with constant width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
     */
    public Builder mergeLinearBuckets(com.google.api.servicecontrol.v1.Distribution.LinearBuckets value) {
      copyOnWrite();
      instance.mergeLinearBuckets(value);
      return this;
    }
    /**
     * <pre>
     * Buckets with constant width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;</code>
     */
    public Builder clearLinearBuckets() {
      copyOnWrite();
      instance.clearLinearBuckets();
      return this;
    }

    /**
     * <pre>
     * Buckets with exponentially growing width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
     */
    public com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets getExponentialBuckets() {
      return instance.getExponentialBuckets();
    }
    /**
     * <pre>
     * Buckets with exponentially growing width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
     */
    public Builder setExponentialBuckets(com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets value) {
      copyOnWrite();
      instance.setExponentialBuckets(value);
      return this;
    }
    /**
     * <pre>
     * Buckets with exponentially growing width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
     */
    public Builder setExponentialBuckets(
        com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.Builder builderForValue) {
      copyOnWrite();
      instance.setExponentialBuckets(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Buckets with exponentially growing width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
     */
    public Builder mergeExponentialBuckets(com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets value) {
      copyOnWrite();
      instance.mergeExponentialBuckets(value);
      return this;
    }
    /**
     * <pre>
     * Buckets with exponentially growing width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;</code>
     */
    public Builder clearExponentialBuckets() {
      copyOnWrite();
      instance.clearExponentialBuckets();
      return this;
    }

    /**
     * <pre>
     * Buckets with arbitrary user-provided width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
     */
    public com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets getExplicitBuckets() {
      return instance.getExplicitBuckets();
    }
    /**
     * <pre>
     * Buckets with arbitrary user-provided width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
     */
    public Builder setExplicitBuckets(com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets value) {
      copyOnWrite();
      instance.setExplicitBuckets(value);
      return this;
    }
    /**
     * <pre>
     * Buckets with arbitrary user-provided width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
     */
    public Builder setExplicitBuckets(
        com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.Builder builderForValue) {
      copyOnWrite();
      instance.setExplicitBuckets(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Buckets with arbitrary user-provided width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
     */
    public Builder mergeExplicitBuckets(com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets value) {
      copyOnWrite();
      instance.mergeExplicitBuckets(value);
      return this;
    }
    /**
     * <pre>
     * Buckets with arbitrary user-provided width.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;</code>
     */
    public Builder clearExplicitBuckets() {
      copyOnWrite();
      instance.clearExplicitBuckets();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.api.servicecontrol.v1.Distribution)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.api.servicecontrol.v1.Distribution();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        bucketCounts_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        com.google.api.servicecontrol.v1.Distribution other = (com.google.api.servicecontrol.v1.Distribution) arg1;
        count_ = visitor.visitLong(count_ != 0L, count_,
            other.count_ != 0L, other.count_);
        mean_ = visitor.visitDouble(mean_ != 0D, mean_,
            other.mean_ != 0D, other.mean_);
        minimum_ = visitor.visitDouble(minimum_ != 0D, minimum_,
            other.minimum_ != 0D, other.minimum_);
        maximum_ = visitor.visitDouble(maximum_ != 0D, maximum_,
            other.maximum_ != 0D, other.maximum_);
        sumOfSquaredDeviation_ = visitor.visitDouble(sumOfSquaredDeviation_ != 0D, sumOfSquaredDeviation_,
            other.sumOfSquaredDeviation_ != 0D, other.sumOfSquaredDeviation_);
        bucketCounts_= visitor.visitLongList(bucketCounts_, other.bucketCounts_);
        switch (other.getBucketOptionCase()) {
          case LINEAR_BUCKETS: {
            bucketOption_ = visitor.visitOneofMessage(
                bucketOptionCase_ == 7,
                bucketOption_,
                other.bucketOption_);
            break;
          }
          case EXPONENTIAL_BUCKETS: {
            bucketOption_ = visitor.visitOneofMessage(
                bucketOptionCase_ == 8,
                bucketOption_,
                other.bucketOption_);
            break;
          }
          case EXPLICIT_BUCKETS: {
            bucketOption_ = visitor.visitOneofMessage(
                bucketOptionCase_ == 9,
                bucketOption_,
                other.bucketOption_);
            break;
          }
          case BUCKETOPTION_NOT_SET: {
            visitor.visitOneofNotSet(bucketOptionCase_ != 0);
            break;
          }
        }
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          if (other.bucketOptionCase_ != 0) {
            bucketOptionCase_ = other.bucketOptionCase_;
          }
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 8: {

                count_ = input.readInt64();
                break;
              }
              case 17: {

                mean_ = input.readDouble();
                break;
              }
              case 25: {

                minimum_ = input.readDouble();
                break;
              }
              case 33: {

                maximum_ = input.readDouble();
                break;
              }
              case 41: {

                sumOfSquaredDeviation_ = input.readDouble();
                break;
              }
              case 48: {
                if (!bucketCounts_.isModifiable()) {
                  bucketCounts_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(bucketCounts_);
                }
                bucketCounts_.addLong(input.readInt64());
                break;
              }
              case 50: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                if (!bucketCounts_.isModifiable() && input.getBytesUntilLimit() > 0) {
                  bucketCounts_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(bucketCounts_);
                }
                while (input.getBytesUntilLimit() > 0) {
                  bucketCounts_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              }
              case 58: {
                com.google.api.servicecontrol.v1.Distribution.LinearBuckets.Builder subBuilder = null;
                if (bucketOptionCase_ == 7) {
                  subBuilder = ((com.google.api.servicecontrol.v1.Distribution.LinearBuckets) bucketOption_).toBuilder();
                }
                bucketOption_ =
                     input.readMessage(com.google.api.servicecontrol.v1.Distribution.LinearBuckets.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.api.servicecontrol.v1.Distribution.LinearBuckets) bucketOption_);
                  bucketOption_ = subBuilder.buildPartial();
                }
                bucketOptionCase_ = 7;
                break;
              }
              case 66: {
                com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.Builder subBuilder = null;
                if (bucketOptionCase_ == 8) {
                  subBuilder = ((com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) bucketOption_).toBuilder();
                }
                bucketOption_ =
                     input.readMessage(com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.api.servicecontrol.v1.Distribution.ExponentialBuckets) bucketOption_);
                  bucketOption_ = subBuilder.buildPartial();
                }
                bucketOptionCase_ = 8;
                break;
              }
              case 74: {
                com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.Builder subBuilder = null;
                if (bucketOptionCase_ == 9) {
                  subBuilder = ((com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) bucketOption_).toBuilder();
                }
                bucketOption_ =
                     input.readMessage(com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom((com.google.api.servicecontrol.v1.Distribution.ExplicitBuckets) bucketOption_);
                  bucketOption_ = subBuilder.buildPartial();
                }
                bucketOptionCase_ = 9;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (com.google.api.servicecontrol.v1.Distribution.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.api.servicecontrol.v1.Distribution)
  private static final com.google.api.servicecontrol.v1.Distribution DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Distribution();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static com.google.api.servicecontrol.v1.Distribution getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<Distribution> PARSER;

  public static com.google.protobuf.Parser<Distribution> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

