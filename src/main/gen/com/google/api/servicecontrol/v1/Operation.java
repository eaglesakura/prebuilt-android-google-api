// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/api/servicecontrol/v1/operation.proto

package com.google.api.servicecontrol.v1;

/**
 * <pre>
 * Represents information regarding an operation.
 * </pre>
 *
 * Protobuf type {@code google.api.servicecontrol.v1.Operation}
 */
public  final class Operation extends
    com.google.protobuf.GeneratedMessageLite<
        Operation, Operation.Builder> implements
    // @@protoc_insertion_point(message_implements:google.api.servicecontrol.v1.Operation)
    OperationOrBuilder {
  private Operation() {
    operationId_ = "";
    operationName_ = "";
    consumerId_ = "";
    metricValueSets_ = emptyProtobufList();
    logEntries_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Defines the importance of the data contained in the operation.
   * </pre>
   *
   * Protobuf enum {@code google.api.servicecontrol.v1.Operation.Importance}
   */
  public enum Importance
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * The API implementation may cache and aggregate the data.
     * The data may be lost when rare and unexpected system failures occur.
     * </pre>
     *
     * <code>LOW = 0;</code>
     */
    LOW(0),
    /**
     * <pre>
     * The API implementation doesn't cache and aggregate the data.
     * If the method returns successfully, it's guaranteed that the data has
     * been persisted in durable storage.
     * </pre>
     *
     * <code>HIGH = 1;</code>
     */
    HIGH(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * The API implementation may cache and aggregate the data.
     * The data may be lost when rare and unexpected system failures occur.
     * </pre>
     *
     * <code>LOW = 0;</code>
     */
    public static final int LOW_VALUE = 0;
    /**
     * <pre>
     * The API implementation doesn't cache and aggregate the data.
     * If the method returns successfully, it's guaranteed that the data has
     * been persisted in durable storage.
     * </pre>
     *
     * <code>HIGH = 1;</code>
     */
    public static final int HIGH_VALUE = 1;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Importance valueOf(int value) {
      return forNumber(value);
    }

    public static Importance forNumber(int value) {
      switch (value) {
        case 0: return LOW;
        case 1: return HIGH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Importance>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Importance> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Importance>() {
            public Importance findValueByNumber(int number) {
              return Importance.forNumber(number);
            }
          };

    private final int value;

    private Importance(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.api.servicecontrol.v1.Operation.Importance)
  }

  private int bitField0_;
  public static final int OPERATION_ID_FIELD_NUMBER = 1;
  private java.lang.String operationId_;
  /**
   * <pre>
   * Identity of the operation. This must be unique within the scope of the
   * service that generated the operation. If the service calls
   * Check() and Report() on the same operation, the two calls should carry
   * the same id.
   * UUID version 4 is recommended, though not required.
   * In scenarios where an operation is computed from existing information
   * and an idempotent id is desirable for deduplication purpose, UUID version 5
   * is recommended. See RFC 4122 for details.
   * </pre>
   *
   * <code>optional string operation_id = 1;</code>
   */
  public java.lang.String getOperationId() {
    return operationId_;
  }
  /**
   * <pre>
   * Identity of the operation. This must be unique within the scope of the
   * service that generated the operation. If the service calls
   * Check() and Report() on the same operation, the two calls should carry
   * the same id.
   * UUID version 4 is recommended, though not required.
   * In scenarios where an operation is computed from existing information
   * and an idempotent id is desirable for deduplication purpose, UUID version 5
   * is recommended. See RFC 4122 for details.
   * </pre>
   *
   * <code>optional string operation_id = 1;</code>
   */
  public com.google.protobuf.ByteString
      getOperationIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(operationId_);
  }
  /**
   * <pre>
   * Identity of the operation. This must be unique within the scope of the
   * service that generated the operation. If the service calls
   * Check() and Report() on the same operation, the two calls should carry
   * the same id.
   * UUID version 4 is recommended, though not required.
   * In scenarios where an operation is computed from existing information
   * and an idempotent id is desirable for deduplication purpose, UUID version 5
   * is recommended. See RFC 4122 for details.
   * </pre>
   *
   * <code>optional string operation_id = 1;</code>
   */
  private void setOperationId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    operationId_ = value;
  }
  /**
   * <pre>
   * Identity of the operation. This must be unique within the scope of the
   * service that generated the operation. If the service calls
   * Check() and Report() on the same operation, the two calls should carry
   * the same id.
   * UUID version 4 is recommended, though not required.
   * In scenarios where an operation is computed from existing information
   * and an idempotent id is desirable for deduplication purpose, UUID version 5
   * is recommended. See RFC 4122 for details.
   * </pre>
   *
   * <code>optional string operation_id = 1;</code>
   */
  private void clearOperationId() {
    
    operationId_ = getDefaultInstance().getOperationId();
  }
  /**
   * <pre>
   * Identity of the operation. This must be unique within the scope of the
   * service that generated the operation. If the service calls
   * Check() and Report() on the same operation, the two calls should carry
   * the same id.
   * UUID version 4 is recommended, though not required.
   * In scenarios where an operation is computed from existing information
   * and an idempotent id is desirable for deduplication purpose, UUID version 5
   * is recommended. See RFC 4122 for details.
   * </pre>
   *
   * <code>optional string operation_id = 1;</code>
   */
  private void setOperationIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    operationId_ = value.toStringUtf8();
  }

  public static final int OPERATION_NAME_FIELD_NUMBER = 2;
  private java.lang.String operationName_;
  /**
   * <pre>
   * Fully qualified name of the operation. Reserved for future use.
   * </pre>
   *
   * <code>optional string operation_name = 2;</code>
   */
  public java.lang.String getOperationName() {
    return operationName_;
  }
  /**
   * <pre>
   * Fully qualified name of the operation. Reserved for future use.
   * </pre>
   *
   * <code>optional string operation_name = 2;</code>
   */
  public com.google.protobuf.ByteString
      getOperationNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(operationName_);
  }
  /**
   * <pre>
   * Fully qualified name of the operation. Reserved for future use.
   * </pre>
   *
   * <code>optional string operation_name = 2;</code>
   */
  private void setOperationName(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    operationName_ = value;
  }
  /**
   * <pre>
   * Fully qualified name of the operation. Reserved for future use.
   * </pre>
   *
   * <code>optional string operation_name = 2;</code>
   */
  private void clearOperationName() {
    
    operationName_ = getDefaultInstance().getOperationName();
  }
  /**
   * <pre>
   * Fully qualified name of the operation. Reserved for future use.
   * </pre>
   *
   * <code>optional string operation_name = 2;</code>
   */
  private void setOperationNameBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    operationName_ = value.toStringUtf8();
  }

  public static final int CONSUMER_ID_FIELD_NUMBER = 3;
  private java.lang.String consumerId_;
  /**
   * <pre>
   * Identity of the consumer who is using the service.
   * This field should be filled in for the operations initiated by a
   * consumer, but not for service-initiated operations that are
   * not related to a specific consumer.
   * This can be in one of the following formats:
   *   project:&lt;project_id&gt;,
   *   project_number:&lt;project_number&gt;,
   *   api_key:&lt;api_key&gt;.
   * </pre>
   *
   * <code>optional string consumer_id = 3;</code>
   */
  public java.lang.String getConsumerId() {
    return consumerId_;
  }
  /**
   * <pre>
   * Identity of the consumer who is using the service.
   * This field should be filled in for the operations initiated by a
   * consumer, but not for service-initiated operations that are
   * not related to a specific consumer.
   * This can be in one of the following formats:
   *   project:&lt;project_id&gt;,
   *   project_number:&lt;project_number&gt;,
   *   api_key:&lt;api_key&gt;.
   * </pre>
   *
   * <code>optional string consumer_id = 3;</code>
   */
  public com.google.protobuf.ByteString
      getConsumerIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(consumerId_);
  }
  /**
   * <pre>
   * Identity of the consumer who is using the service.
   * This field should be filled in for the operations initiated by a
   * consumer, but not for service-initiated operations that are
   * not related to a specific consumer.
   * This can be in one of the following formats:
   *   project:&lt;project_id&gt;,
   *   project_number:&lt;project_number&gt;,
   *   api_key:&lt;api_key&gt;.
   * </pre>
   *
   * <code>optional string consumer_id = 3;</code>
   */
  private void setConsumerId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    consumerId_ = value;
  }
  /**
   * <pre>
   * Identity of the consumer who is using the service.
   * This field should be filled in for the operations initiated by a
   * consumer, but not for service-initiated operations that are
   * not related to a specific consumer.
   * This can be in one of the following formats:
   *   project:&lt;project_id&gt;,
   *   project_number:&lt;project_number&gt;,
   *   api_key:&lt;api_key&gt;.
   * </pre>
   *
   * <code>optional string consumer_id = 3;</code>
   */
  private void clearConsumerId() {
    
    consumerId_ = getDefaultInstance().getConsumerId();
  }
  /**
   * <pre>
   * Identity of the consumer who is using the service.
   * This field should be filled in for the operations initiated by a
   * consumer, but not for service-initiated operations that are
   * not related to a specific consumer.
   * This can be in one of the following formats:
   *   project:&lt;project_id&gt;,
   *   project_number:&lt;project_number&gt;,
   *   api_key:&lt;api_key&gt;.
   * </pre>
   *
   * <code>optional string consumer_id = 3;</code>
   */
  private void setConsumerIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    consumerId_ = value.toStringUtf8();
  }

  public static final int START_TIME_FIELD_NUMBER = 4;
  private com.google.protobuf.Timestamp startTime_;
  /**
   * <pre>
   * Required. Start time of the operation.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
   */
  public boolean hasStartTime() {
    return startTime_ != null;
  }
  /**
   * <pre>
   * Required. Start time of the operation.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
   */
  public com.google.protobuf.Timestamp getStartTime() {
    return startTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : startTime_;
  }
  /**
   * <pre>
   * Required. Start time of the operation.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
   */
  private void setStartTime(com.google.protobuf.Timestamp value) {
    if (value == null) {
      throw new NullPointerException();
    }
    startTime_ = value;
    
    }
  /**
   * <pre>
   * Required. Start time of the operation.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
   */
  private void setStartTime(
      com.google.protobuf.Timestamp.Builder builderForValue) {
    startTime_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * Required. Start time of the operation.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
   */
  private void mergeStartTime(com.google.protobuf.Timestamp value) {
    if (startTime_ != null &&
        startTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      startTime_ =
        com.google.protobuf.Timestamp.newBuilder(startTime_).mergeFrom(value).buildPartial();
    } else {
      startTime_ = value;
    }
    
  }
  /**
   * <pre>
   * Required. Start time of the operation.
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
   */
  private void clearStartTime() {  startTime_ = null;
    
  }

  public static final int END_TIME_FIELD_NUMBER = 5;
  private com.google.protobuf.Timestamp endTime_;
  /**
   * <pre>
   * End time of the operation.
   * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
   * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
   */
  public boolean hasEndTime() {
    return endTime_ != null;
  }
  /**
   * <pre>
   * End time of the operation.
   * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
   * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
   */
  public com.google.protobuf.Timestamp getEndTime() {
    return endTime_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : endTime_;
  }
  /**
   * <pre>
   * End time of the operation.
   * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
   * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
   */
  private void setEndTime(com.google.protobuf.Timestamp value) {
    if (value == null) {
      throw new NullPointerException();
    }
    endTime_ = value;
    
    }
  /**
   * <pre>
   * End time of the operation.
   * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
   * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
   */
  private void setEndTime(
      com.google.protobuf.Timestamp.Builder builderForValue) {
    endTime_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * End time of the operation.
   * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
   * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
   */
  private void mergeEndTime(com.google.protobuf.Timestamp value) {
    if (endTime_ != null &&
        endTime_ != com.google.protobuf.Timestamp.getDefaultInstance()) {
      endTime_ =
        com.google.protobuf.Timestamp.newBuilder(endTime_).mergeFrom(value).buildPartial();
    } else {
      endTime_ = value;
    }
    
  }
  /**
   * <pre>
   * End time of the operation.
   * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
   * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
   * </pre>
   *
   * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
   */
  private void clearEndTime() {  endTime_ = null;
    
  }

  public static final int LABELS_FIELD_NUMBER = 6;
  private static final class LabelsDefaultEntryHolder {
    static final com.google.protobuf.MapEntryLite<
        java.lang.String, java.lang.String> defaultEntry =
            com.google.protobuf.MapEntryLite
            .<java.lang.String, java.lang.String>newDefaultInstance(
                com.google.protobuf.WireFormat.FieldType.STRING,
                "",
                com.google.protobuf.WireFormat.FieldType.STRING,
                "");
  }
  private com.google.protobuf.MapFieldLite<
      java.lang.String, java.lang.String> labels_ =
          com.google.protobuf.MapFieldLite.emptyMapField();
  private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
  internalGetLabels() {
    return labels_;
  }
  private com.google.protobuf.MapFieldLite<java.lang.String, java.lang.String>
  internalGetMutableLabels() {
    if (!labels_.isMutable()) {
      labels_ = labels_.mutableCopy();
    }
    return labels_;
  }

  public int getLabelsCount() {
    return internalGetLabels().size();
  }
  /**
   * <pre>
   * Labels describing the operation. Only the following labels are allowed:
   * - Labels describing monitored resources as defined in
   *   the service configuration.
   * - Default labels of metric values. When specified, labels defined in the
   *   metric value override these default.
   * - The following labels defined by Google Cloud Platform:
   *     - `cloud.googleapis.com/location` describing the location where the
   *        operation happened,
   *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
   *        of the API request,
   *     - `servicecontrol.googleapis.com/service_agent` describing the service
   *        used to handle the API request (e.g. ESP),
   *     - `servicecontrol.googleapis.com/platform` describing the platform
   *        where the API is served (e.g. GAE, GCE, GKE).
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public boolean containsLabels(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    return internalGetLabels().containsKey(key);
  }
  /**
   * Use {@link #getLabelsMap()} instead.
   */
  @java.lang.Deprecated
  public java.util.Map<java.lang.String, java.lang.String> getLabels() {
    return getLabelsMap();
  }
  /**
   * <pre>
   * Labels describing the operation. Only the following labels are allowed:
   * - Labels describing monitored resources as defined in
   *   the service configuration.
   * - Default labels of metric values. When specified, labels defined in the
   *   metric value override these default.
   * - The following labels defined by Google Cloud Platform:
   *     - `cloud.googleapis.com/location` describing the location where the
   *        operation happened,
   *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
   *        of the API request,
   *     - `servicecontrol.googleapis.com/service_agent` describing the service
   *        used to handle the API request (e.g. ESP),
   *     - `servicecontrol.googleapis.com/platform` describing the platform
   *        where the API is served (e.g. GAE, GCE, GKE).
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
    return java.util.Collections.unmodifiableMap(
        internalGetLabels());
  }
  /**
   * <pre>
   * Labels describing the operation. Only the following labels are allowed:
   * - Labels describing monitored resources as defined in
   *   the service configuration.
   * - Default labels of metric values. When specified, labels defined in the
   *   metric value override these default.
   * - The following labels defined by Google Cloud Platform:
   *     - `cloud.googleapis.com/location` describing the location where the
   *        operation happened,
   *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
   *        of the API request,
   *     - `servicecontrol.googleapis.com/service_agent` describing the service
   *        used to handle the API request (e.g. ESP),
   *     - `servicecontrol.googleapis.com/platform` describing the platform
   *        where the API is served (e.g. GAE, GCE, GKE).
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public java.lang.String getLabelsOrDefault(
      java.lang.String key,
      java.lang.String defaultValue) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetLabels();
    return map.containsKey(key) ? map.get(key) : defaultValue;
  }
  /**
   * <pre>
   * Labels describing the operation. Only the following labels are allowed:
   * - Labels describing monitored resources as defined in
   *   the service configuration.
   * - Default labels of metric values. When specified, labels defined in the
   *   metric value override these default.
   * - The following labels defined by Google Cloud Platform:
   *     - `cloud.googleapis.com/location` describing the location where the
   *        operation happened,
   *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
   *        of the API request,
   *     - `servicecontrol.googleapis.com/service_agent` describing the service
   *        used to handle the API request (e.g. ESP),
   *     - `servicecontrol.googleapis.com/platform` describing the platform
   *        where the API is served (e.g. GAE, GCE, GKE).
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */

  public java.lang.String getLabelsOrThrow(
      java.lang.String key) {
    if (key == null) { throw new java.lang.NullPointerException(); }
    java.util.Map<java.lang.String, java.lang.String> map =
        internalGetLabels();
    if (!map.containsKey(key)) {
      throw new java.lang.IllegalArgumentException();
    }
    return map.get(key);
  }
  /**
   * <pre>
   * Labels describing the operation. Only the following labels are allowed:
   * - Labels describing monitored resources as defined in
   *   the service configuration.
   * - Default labels of metric values. When specified, labels defined in the
   *   metric value override these default.
   * - The following labels defined by Google Cloud Platform:
   *     - `cloud.googleapis.com/location` describing the location where the
   *        operation happened,
   *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
   *        of the API request,
   *     - `servicecontrol.googleapis.com/service_agent` describing the service
   *        used to handle the API request (e.g. ESP),
   *     - `servicecontrol.googleapis.com/platform` describing the platform
   *        where the API is served (e.g. GAE, GCE, GKE).
   * </pre>
   *
   * <code>map&lt;string, string&gt; labels = 6;</code>
   */
  private java.util.Map<java.lang.String, java.lang.String>
  getMutableLabelsMap() {
    return internalGetMutableLabels();
  }

  public static final int METRIC_VALUE_SETS_FIELD_NUMBER = 7;
  private com.google.protobuf.Internal.ProtobufList<com.google.api.servicecontrol.v1.MetricValueSet> metricValueSets_;
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  public java.util.List<com.google.api.servicecontrol.v1.MetricValueSet> getMetricValueSetsList() {
    return metricValueSets_;
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  public java.util.List<? extends com.google.api.servicecontrol.v1.MetricValueSetOrBuilder> 
      getMetricValueSetsOrBuilderList() {
    return metricValueSets_;
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  public int getMetricValueSetsCount() {
    return metricValueSets_.size();
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  public com.google.api.servicecontrol.v1.MetricValueSet getMetricValueSets(int index) {
    return metricValueSets_.get(index);
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  public com.google.api.servicecontrol.v1.MetricValueSetOrBuilder getMetricValueSetsOrBuilder(
      int index) {
    return metricValueSets_.get(index);
  }
  private void ensureMetricValueSetsIsMutable() {
    if (!metricValueSets_.isModifiable()) {
      metricValueSets_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(metricValueSets_);
     }
  }

  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void setMetricValueSets(
      int index, com.google.api.servicecontrol.v1.MetricValueSet value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureMetricValueSetsIsMutable();
    metricValueSets_.set(index, value);
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void setMetricValueSets(
      int index, com.google.api.servicecontrol.v1.MetricValueSet.Builder builderForValue) {
    ensureMetricValueSetsIsMutable();
    metricValueSets_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void addMetricValueSets(com.google.api.servicecontrol.v1.MetricValueSet value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureMetricValueSetsIsMutable();
    metricValueSets_.add(value);
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void addMetricValueSets(
      int index, com.google.api.servicecontrol.v1.MetricValueSet value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureMetricValueSetsIsMutable();
    metricValueSets_.add(index, value);
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void addMetricValueSets(
      com.google.api.servicecontrol.v1.MetricValueSet.Builder builderForValue) {
    ensureMetricValueSetsIsMutable();
    metricValueSets_.add(builderForValue.build());
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void addMetricValueSets(
      int index, com.google.api.servicecontrol.v1.MetricValueSet.Builder builderForValue) {
    ensureMetricValueSetsIsMutable();
    metricValueSets_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void addAllMetricValueSets(
      java.lang.Iterable<? extends com.google.api.servicecontrol.v1.MetricValueSet> values) {
    ensureMetricValueSetsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, metricValueSets_);
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void clearMetricValueSets() {
    metricValueSets_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Represents information about this operation. Each MetricValueSet
   * corresponds to a metric defined in the service configuration.
   * The data type used in the MetricValueSet must agree with
   * the data type specified in the metric definition.
   * Within a single operation, it is not allowed to have more than one
   * MetricValue instances that have the same metric names and identical
   * label value combinations. If a request has such duplicated MetricValue
   * instances, the entire request is rejected with
   * an invalid argument error.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
   */
  private void removeMetricValueSets(int index) {
    ensureMetricValueSetsIsMutable();
    metricValueSets_.remove(index);
  }

  public static final int LOG_ENTRIES_FIELD_NUMBER = 8;
  private com.google.protobuf.Internal.ProtobufList<com.google.api.servicecontrol.v1.LogEntry> logEntries_;
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  public java.util.List<com.google.api.servicecontrol.v1.LogEntry> getLogEntriesList() {
    return logEntries_;
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  public java.util.List<? extends com.google.api.servicecontrol.v1.LogEntryOrBuilder> 
      getLogEntriesOrBuilderList() {
    return logEntries_;
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  public int getLogEntriesCount() {
    return logEntries_.size();
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  public com.google.api.servicecontrol.v1.LogEntry getLogEntries(int index) {
    return logEntries_.get(index);
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  public com.google.api.servicecontrol.v1.LogEntryOrBuilder getLogEntriesOrBuilder(
      int index) {
    return logEntries_.get(index);
  }
  private void ensureLogEntriesIsMutable() {
    if (!logEntries_.isModifiable()) {
      logEntries_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(logEntries_);
     }
  }

  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void setLogEntries(
      int index, com.google.api.servicecontrol.v1.LogEntry value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureLogEntriesIsMutable();
    logEntries_.set(index, value);
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void setLogEntries(
      int index, com.google.api.servicecontrol.v1.LogEntry.Builder builderForValue) {
    ensureLogEntriesIsMutable();
    logEntries_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void addLogEntries(com.google.api.servicecontrol.v1.LogEntry value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureLogEntriesIsMutable();
    logEntries_.add(value);
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void addLogEntries(
      int index, com.google.api.servicecontrol.v1.LogEntry value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureLogEntriesIsMutable();
    logEntries_.add(index, value);
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void addLogEntries(
      com.google.api.servicecontrol.v1.LogEntry.Builder builderForValue) {
    ensureLogEntriesIsMutable();
    logEntries_.add(builderForValue.build());
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void addLogEntries(
      int index, com.google.api.servicecontrol.v1.LogEntry.Builder builderForValue) {
    ensureLogEntriesIsMutable();
    logEntries_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void addAllLogEntries(
      java.lang.Iterable<? extends com.google.api.servicecontrol.v1.LogEntry> values) {
    ensureLogEntriesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, logEntries_);
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void clearLogEntries() {
    logEntries_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Represents information to be logged.
   * </pre>
   *
   * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
   */
  private void removeLogEntries(int index) {
    ensureLogEntriesIsMutable();
    logEntries_.remove(index);
  }

  public static final int IMPORTANCE_FIELD_NUMBER = 11;
  private int importance_;
  /**
   * <pre>
   * DO NOT USE. This is an experimental field.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
   */
  public int getImportanceValue() {
    return importance_;
  }
  /**
   * <pre>
   * DO NOT USE. This is an experimental field.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
   */
  public com.google.api.servicecontrol.v1.Operation.Importance getImportance() {
    com.google.api.servicecontrol.v1.Operation.Importance result = com.google.api.servicecontrol.v1.Operation.Importance.forNumber(importance_);
    return result == null ? com.google.api.servicecontrol.v1.Operation.Importance.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * DO NOT USE. This is an experimental field.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
   */
  private void setImportanceValue(int value) {
      importance_ = value;
  }
  /**
   * <pre>
   * DO NOT USE. This is an experimental field.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
   */
  private void setImportance(com.google.api.servicecontrol.v1.Operation.Importance value) {
    if (value == null) {
      throw new NullPointerException();
    }
    
    importance_ = value.getNumber();
  }
  /**
   * <pre>
   * DO NOT USE. This is an experimental field.
   * </pre>
   *
   * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
   */
  private void clearImportance() {
    
    importance_ = 0;
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!operationId_.isEmpty()) {
      output.writeString(1, getOperationId());
    }
    if (!operationName_.isEmpty()) {
      output.writeString(2, getOperationName());
    }
    if (!consumerId_.isEmpty()) {
      output.writeString(3, getConsumerId());
    }
    if (startTime_ != null) {
      output.writeMessage(4, getStartTime());
    }
    if (endTime_ != null) {
      output.writeMessage(5, getEndTime());
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetLabels().entrySet()) {
      LabelsDefaultEntryHolder.defaultEntry.serializeTo(
          output, 6, entry.getKey(), entry.getValue());
    }
    for (int i = 0; i < metricValueSets_.size(); i++) {
      output.writeMessage(7, metricValueSets_.get(i));
    }
    for (int i = 0; i < logEntries_.size(); i++) {
      output.writeMessage(8, logEntries_.get(i));
    }
    if (importance_ != com.google.api.servicecontrol.v1.Operation.Importance.LOW.getNumber()) {
      output.writeEnum(11, importance_);
    }
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (!operationId_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(1, getOperationId());
    }
    if (!operationName_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(2, getOperationName());
    }
    if (!consumerId_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(3, getConsumerId());
    }
    if (startTime_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getStartTime());
    }
    if (endTime_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getEndTime());
    }
    for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
         : internalGetLabels().entrySet()) {
      size += LabelsDefaultEntryHolder.defaultEntry.computeMessageSize(
        6, entry.getKey(), entry.getValue());
    }
    for (int i = 0; i < metricValueSets_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, metricValueSets_.get(i));
    }
    for (int i = 0; i < logEntries_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(8, logEntries_.get(i));
    }
    if (importance_ != com.google.api.servicecontrol.v1.Operation.Importance.LOW.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(11, importance_);
    }
    memoizedSerializedSize = size;
    return size;
  }

  public static com.google.api.servicecontrol.v1.Operation parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Operation parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.api.servicecontrol.v1.Operation parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.api.servicecontrol.v1.Operation parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.api.servicecontrol.v1.Operation prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * Represents information regarding an operation.
   * </pre>
   *
   * Protobuf type {@code google.api.servicecontrol.v1.Operation}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.api.servicecontrol.v1.Operation, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.api.servicecontrol.v1.Operation)
      com.google.api.servicecontrol.v1.OperationOrBuilder {
    // Construct using com.google.api.servicecontrol.v1.Operation.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * Identity of the operation. This must be unique within the scope of the
     * service that generated the operation. If the service calls
     * Check() and Report() on the same operation, the two calls should carry
     * the same id.
     * UUID version 4 is recommended, though not required.
     * In scenarios where an operation is computed from existing information
     * and an idempotent id is desirable for deduplication purpose, UUID version 5
     * is recommended. See RFC 4122 for details.
     * </pre>
     *
     * <code>optional string operation_id = 1;</code>
     */
    public java.lang.String getOperationId() {
      return instance.getOperationId();
    }
    /**
     * <pre>
     * Identity of the operation. This must be unique within the scope of the
     * service that generated the operation. If the service calls
     * Check() and Report() on the same operation, the two calls should carry
     * the same id.
     * UUID version 4 is recommended, though not required.
     * In scenarios where an operation is computed from existing information
     * and an idempotent id is desirable for deduplication purpose, UUID version 5
     * is recommended. See RFC 4122 for details.
     * </pre>
     *
     * <code>optional string operation_id = 1;</code>
     */
    public com.google.protobuf.ByteString
        getOperationIdBytes() {
      return instance.getOperationIdBytes();
    }
    /**
     * <pre>
     * Identity of the operation. This must be unique within the scope of the
     * service that generated the operation. If the service calls
     * Check() and Report() on the same operation, the two calls should carry
     * the same id.
     * UUID version 4 is recommended, though not required.
     * In scenarios where an operation is computed from existing information
     * and an idempotent id is desirable for deduplication purpose, UUID version 5
     * is recommended. See RFC 4122 for details.
     * </pre>
     *
     * <code>optional string operation_id = 1;</code>
     */
    public Builder setOperationId(
        java.lang.String value) {
      copyOnWrite();
      instance.setOperationId(value);
      return this;
    }
    /**
     * <pre>
     * Identity of the operation. This must be unique within the scope of the
     * service that generated the operation. If the service calls
     * Check() and Report() on the same operation, the two calls should carry
     * the same id.
     * UUID version 4 is recommended, though not required.
     * In scenarios where an operation is computed from existing information
     * and an idempotent id is desirable for deduplication purpose, UUID version 5
     * is recommended. See RFC 4122 for details.
     * </pre>
     *
     * <code>optional string operation_id = 1;</code>
     */
    public Builder clearOperationId() {
      copyOnWrite();
      instance.clearOperationId();
      return this;
    }
    /**
     * <pre>
     * Identity of the operation. This must be unique within the scope of the
     * service that generated the operation. If the service calls
     * Check() and Report() on the same operation, the two calls should carry
     * the same id.
     * UUID version 4 is recommended, though not required.
     * In scenarios where an operation is computed from existing information
     * and an idempotent id is desirable for deduplication purpose, UUID version 5
     * is recommended. See RFC 4122 for details.
     * </pre>
     *
     * <code>optional string operation_id = 1;</code>
     */
    public Builder setOperationIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOperationIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * Fully qualified name of the operation. Reserved for future use.
     * </pre>
     *
     * <code>optional string operation_name = 2;</code>
     */
    public java.lang.String getOperationName() {
      return instance.getOperationName();
    }
    /**
     * <pre>
     * Fully qualified name of the operation. Reserved for future use.
     * </pre>
     *
     * <code>optional string operation_name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getOperationNameBytes() {
      return instance.getOperationNameBytes();
    }
    /**
     * <pre>
     * Fully qualified name of the operation. Reserved for future use.
     * </pre>
     *
     * <code>optional string operation_name = 2;</code>
     */
    public Builder setOperationName(
        java.lang.String value) {
      copyOnWrite();
      instance.setOperationName(value);
      return this;
    }
    /**
     * <pre>
     * Fully qualified name of the operation. Reserved for future use.
     * </pre>
     *
     * <code>optional string operation_name = 2;</code>
     */
    public Builder clearOperationName() {
      copyOnWrite();
      instance.clearOperationName();
      return this;
    }
    /**
     * <pre>
     * Fully qualified name of the operation. Reserved for future use.
     * </pre>
     *
     * <code>optional string operation_name = 2;</code>
     */
    public Builder setOperationNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOperationNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * Identity of the consumer who is using the service.
     * This field should be filled in for the operations initiated by a
     * consumer, but not for service-initiated operations that are
     * not related to a specific consumer.
     * This can be in one of the following formats:
     *   project:&lt;project_id&gt;,
     *   project_number:&lt;project_number&gt;,
     *   api_key:&lt;api_key&gt;.
     * </pre>
     *
     * <code>optional string consumer_id = 3;</code>
     */
    public java.lang.String getConsumerId() {
      return instance.getConsumerId();
    }
    /**
     * <pre>
     * Identity of the consumer who is using the service.
     * This field should be filled in for the operations initiated by a
     * consumer, but not for service-initiated operations that are
     * not related to a specific consumer.
     * This can be in one of the following formats:
     *   project:&lt;project_id&gt;,
     *   project_number:&lt;project_number&gt;,
     *   api_key:&lt;api_key&gt;.
     * </pre>
     *
     * <code>optional string consumer_id = 3;</code>
     */
    public com.google.protobuf.ByteString
        getConsumerIdBytes() {
      return instance.getConsumerIdBytes();
    }
    /**
     * <pre>
     * Identity of the consumer who is using the service.
     * This field should be filled in for the operations initiated by a
     * consumer, but not for service-initiated operations that are
     * not related to a specific consumer.
     * This can be in one of the following formats:
     *   project:&lt;project_id&gt;,
     *   project_number:&lt;project_number&gt;,
     *   api_key:&lt;api_key&gt;.
     * </pre>
     *
     * <code>optional string consumer_id = 3;</code>
     */
    public Builder setConsumerId(
        java.lang.String value) {
      copyOnWrite();
      instance.setConsumerId(value);
      return this;
    }
    /**
     * <pre>
     * Identity of the consumer who is using the service.
     * This field should be filled in for the operations initiated by a
     * consumer, but not for service-initiated operations that are
     * not related to a specific consumer.
     * This can be in one of the following formats:
     *   project:&lt;project_id&gt;,
     *   project_number:&lt;project_number&gt;,
     *   api_key:&lt;api_key&gt;.
     * </pre>
     *
     * <code>optional string consumer_id = 3;</code>
     */
    public Builder clearConsumerId() {
      copyOnWrite();
      instance.clearConsumerId();
      return this;
    }
    /**
     * <pre>
     * Identity of the consumer who is using the service.
     * This field should be filled in for the operations initiated by a
     * consumer, but not for service-initiated operations that are
     * not related to a specific consumer.
     * This can be in one of the following formats:
     *   project:&lt;project_id&gt;,
     *   project_number:&lt;project_number&gt;,
     *   api_key:&lt;api_key&gt;.
     * </pre>
     *
     * <code>optional string consumer_id = 3;</code>
     */
    public Builder setConsumerIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setConsumerIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * Required. Start time of the operation.
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
     */
    public boolean hasStartTime() {
      return instance.hasStartTime();
    }
    /**
     * <pre>
     * Required. Start time of the operation.
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
     */
    public com.google.protobuf.Timestamp getStartTime() {
      return instance.getStartTime();
    }
    /**
     * <pre>
     * Required. Start time of the operation.
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
     */
    public Builder setStartTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setStartTime(value);
      return this;
      }
    /**
     * <pre>
     * Required. Start time of the operation.
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
     */
    public Builder setStartTime(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setStartTime(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Required. Start time of the operation.
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
     */
    public Builder mergeStartTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeStartTime(value);
      return this;
    }
    /**
     * <pre>
     * Required. Start time of the operation.
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp start_time = 4;</code>
     */
    public Builder clearStartTime() {  copyOnWrite();
      instance.clearStartTime();
      return this;
    }

    /**
     * <pre>
     * End time of the operation.
     * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
     * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
     */
    public boolean hasEndTime() {
      return instance.hasEndTime();
    }
    /**
     * <pre>
     * End time of the operation.
     * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
     * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
     */
    public com.google.protobuf.Timestamp getEndTime() {
      return instance.getEndTime();
    }
    /**
     * <pre>
     * End time of the operation.
     * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
     * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
     */
    public Builder setEndTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.setEndTime(value);
      return this;
      }
    /**
     * <pre>
     * End time of the operation.
     * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
     * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
     */
    public Builder setEndTime(
        com.google.protobuf.Timestamp.Builder builderForValue) {
      copyOnWrite();
      instance.setEndTime(builderForValue);
      return this;
    }
    /**
     * <pre>
     * End time of the operation.
     * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
     * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
     */
    public Builder mergeEndTime(com.google.protobuf.Timestamp value) {
      copyOnWrite();
      instance.mergeEndTime(value);
      return this;
    }
    /**
     * <pre>
     * End time of the operation.
     * Required when the operation is used in [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
     * but optional when the operation is used in [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
     * </pre>
     *
     * <code>optional .google.protobuf.Timestamp end_time = 5;</code>
     */
    public Builder clearEndTime() {  copyOnWrite();
      instance.clearEndTime();
      return this;
    }


    public int getLabelsCount() {
      return instance.getLabelsMap().size();
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public boolean containsLabels(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      return instance.getLabelsMap().containsKey(key);
    }

    public Builder clearLabels() {
      copyOnWrite();
      instance.getMutableLabelsMap().clear();
      return this;
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public Builder removeLabels(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      copyOnWrite();
      instance.getMutableLabelsMap().remove(key);
      return this;
    }
    /**
     * Use {@link #getLabelsMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getLabels() {
      return getLabelsMap();
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */
    public java.util.Map<java.lang.String, java.lang.String> getLabelsMap() {
      return java.util.Collections.unmodifiableMap(
          instance.getLabelsMap());
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public java.lang.String getLabelsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          instance.getLabelsMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */

    public java.lang.String getLabelsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      java.util.Map<java.lang.String, java.lang.String> map =
          instance.getLabelsMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */
    public Builder putLabels(
        java.lang.String key,
        java.lang.String value) {
      if (key == null) { throw new java.lang.NullPointerException(); }
      if (value == null) { throw new java.lang.NullPointerException(); }
      copyOnWrite();
      instance.getMutableLabelsMap().put(key, value);
      return this;
    }
    /**
     * <pre>
     * Labels describing the operation. Only the following labels are allowed:
     * - Labels describing monitored resources as defined in
     *   the service configuration.
     * - Default labels of metric values. When specified, labels defined in the
     *   metric value override these default.
     * - The following labels defined by Google Cloud Platform:
     *     - `cloud.googleapis.com/location` describing the location where the
     *        operation happened,
     *     - `servicecontrol.googleapis.com/user_agent` describing the user agent
     *        of the API request,
     *     - `servicecontrol.googleapis.com/service_agent` describing the service
     *        used to handle the API request (e.g. ESP),
     *     - `servicecontrol.googleapis.com/platform` describing the platform
     *        where the API is served (e.g. GAE, GCE, GKE).
     * </pre>
     *
     * <code>map&lt;string, string&gt; labels = 6;</code>
     */
    public Builder putAllLabels(
        java.util.Map<java.lang.String, java.lang.String> values) {
      copyOnWrite();
      instance.getMutableLabelsMap().putAll(values);
      return this;
    }

    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public java.util.List<com.google.api.servicecontrol.v1.MetricValueSet> getMetricValueSetsList() {
      return java.util.Collections.unmodifiableList(
          instance.getMetricValueSetsList());
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public int getMetricValueSetsCount() {
      return instance.getMetricValueSetsCount();
    }/**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public com.google.api.servicecontrol.v1.MetricValueSet getMetricValueSets(int index) {
      return instance.getMetricValueSets(index);
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder setMetricValueSets(
        int index, com.google.api.servicecontrol.v1.MetricValueSet value) {
      copyOnWrite();
      instance.setMetricValueSets(index, value);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder setMetricValueSets(
        int index, com.google.api.servicecontrol.v1.MetricValueSet.Builder builderForValue) {
      copyOnWrite();
      instance.setMetricValueSets(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder addMetricValueSets(com.google.api.servicecontrol.v1.MetricValueSet value) {
      copyOnWrite();
      instance.addMetricValueSets(value);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder addMetricValueSets(
        int index, com.google.api.servicecontrol.v1.MetricValueSet value) {
      copyOnWrite();
      instance.addMetricValueSets(index, value);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder addMetricValueSets(
        com.google.api.servicecontrol.v1.MetricValueSet.Builder builderForValue) {
      copyOnWrite();
      instance.addMetricValueSets(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder addMetricValueSets(
        int index, com.google.api.servicecontrol.v1.MetricValueSet.Builder builderForValue) {
      copyOnWrite();
      instance.addMetricValueSets(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder addAllMetricValueSets(
        java.lang.Iterable<? extends com.google.api.servicecontrol.v1.MetricValueSet> values) {
      copyOnWrite();
      instance.addAllMetricValueSets(values);
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder clearMetricValueSets() {
      copyOnWrite();
      instance.clearMetricValueSets();
      return this;
    }
    /**
     * <pre>
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.MetricValueSet metric_value_sets = 7;</code>
     */
    public Builder removeMetricValueSets(int index) {
      copyOnWrite();
      instance.removeMetricValueSets(index);
      return this;
    }

    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public java.util.List<com.google.api.servicecontrol.v1.LogEntry> getLogEntriesList() {
      return java.util.Collections.unmodifiableList(
          instance.getLogEntriesList());
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public int getLogEntriesCount() {
      return instance.getLogEntriesCount();
    }/**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public com.google.api.servicecontrol.v1.LogEntry getLogEntries(int index) {
      return instance.getLogEntries(index);
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder setLogEntries(
        int index, com.google.api.servicecontrol.v1.LogEntry value) {
      copyOnWrite();
      instance.setLogEntries(index, value);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder setLogEntries(
        int index, com.google.api.servicecontrol.v1.LogEntry.Builder builderForValue) {
      copyOnWrite();
      instance.setLogEntries(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder addLogEntries(com.google.api.servicecontrol.v1.LogEntry value) {
      copyOnWrite();
      instance.addLogEntries(value);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder addLogEntries(
        int index, com.google.api.servicecontrol.v1.LogEntry value) {
      copyOnWrite();
      instance.addLogEntries(index, value);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder addLogEntries(
        com.google.api.servicecontrol.v1.LogEntry.Builder builderForValue) {
      copyOnWrite();
      instance.addLogEntries(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder addLogEntries(
        int index, com.google.api.servicecontrol.v1.LogEntry.Builder builderForValue) {
      copyOnWrite();
      instance.addLogEntries(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder addAllLogEntries(
        java.lang.Iterable<? extends com.google.api.servicecontrol.v1.LogEntry> values) {
      copyOnWrite();
      instance.addAllLogEntries(values);
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder clearLogEntries() {
      copyOnWrite();
      instance.clearLogEntries();
      return this;
    }
    /**
     * <pre>
     * Represents information to be logged.
     * </pre>
     *
     * <code>repeated .google.api.servicecontrol.v1.LogEntry log_entries = 8;</code>
     */
    public Builder removeLogEntries(int index) {
      copyOnWrite();
      instance.removeLogEntries(index);
      return this;
    }

    /**
     * <pre>
     * DO NOT USE. This is an experimental field.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
     */
    public int getImportanceValue() {
      return instance.getImportanceValue();
    }
    /**
     * <pre>
     * DO NOT USE. This is an experimental field.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
     */
    public Builder setImportanceValue(int value) {
      copyOnWrite();
      instance.setImportanceValue(value);
      return this;
    }
    /**
     * <pre>
     * DO NOT USE. This is an experimental field.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
     */
    public com.google.api.servicecontrol.v1.Operation.Importance getImportance() {
      return instance.getImportance();
    }
    /**
     * <pre>
     * DO NOT USE. This is an experimental field.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
     */
    public Builder setImportance(com.google.api.servicecontrol.v1.Operation.Importance value) {
      copyOnWrite();
      instance.setImportance(value);
      return this;
    }
    /**
     * <pre>
     * DO NOT USE. This is an experimental field.
     * </pre>
     *
     * <code>optional .google.api.servicecontrol.v1.Operation.Importance importance = 11;</code>
     */
    public Builder clearImportance() {
      copyOnWrite();
      instance.clearImportance();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.api.servicecontrol.v1.Operation)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.api.servicecontrol.v1.Operation();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        labels_.makeImmutable();
        metricValueSets_.makeImmutable();
        logEntries_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        com.google.api.servicecontrol.v1.Operation other = (com.google.api.servicecontrol.v1.Operation) arg1;
        operationId_ = visitor.visitString(!operationId_.isEmpty(), operationId_,
            !other.operationId_.isEmpty(), other.operationId_);
        operationName_ = visitor.visitString(!operationName_.isEmpty(), operationName_,
            !other.operationName_.isEmpty(), other.operationName_);
        consumerId_ = visitor.visitString(!consumerId_.isEmpty(), consumerId_,
            !other.consumerId_.isEmpty(), other.consumerId_);
        startTime_ = visitor.visitMessage(startTime_, other.startTime_);
        endTime_ = visitor.visitMessage(endTime_, other.endTime_);
        labels_ = visitor.visitMap(
            labels_, other.internalGetLabels());
        metricValueSets_= visitor.visitList(metricValueSets_, other.metricValueSets_);
        logEntries_= visitor.visitList(logEntries_, other.logEntries_);
        importance_ = visitor.visitInt(importance_ != 0, importance_,    other.importance_ != 0, other.importance_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                String s = input.readStringRequireUtf8();

                operationId_ = s;
                break;
              }
              case 18: {
                String s = input.readStringRequireUtf8();

                operationName_ = s;
                break;
              }
              case 26: {
                String s = input.readStringRequireUtf8();

                consumerId_ = s;
                break;
              }
              case 34: {
                com.google.protobuf.Timestamp.Builder subBuilder = null;
                if (startTime_ != null) {
                  subBuilder = startTime_.toBuilder();
                }
                startTime_ = input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(startTime_);
                  startTime_ = subBuilder.buildPartial();
                }

                break;
              }
              case 42: {
                com.google.protobuf.Timestamp.Builder subBuilder = null;
                if (endTime_ != null) {
                  subBuilder = endTime_.toBuilder();
                }
                endTime_ = input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(endTime_);
                  endTime_ = subBuilder.buildPartial();
                }

                break;
              }
              case 50: {
                if (!labels_.isMutable()) {
                  labels_ = labels_.mutableCopy();
                }
                LabelsDefaultEntryHolder.defaultEntry.parseInto(labels_, input, extensionRegistry);  break;
              }
              case 58: {
                if (!metricValueSets_.isModifiable()) {
                  metricValueSets_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(metricValueSets_);
                }
                metricValueSets_.add(
                    input.readMessage(com.google.api.servicecontrol.v1.MetricValueSet.parser(), extensionRegistry));
                break;
              }
              case 66: {
                if (!logEntries_.isModifiable()) {
                  logEntries_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(logEntries_);
                }
                logEntries_.add(
                    input.readMessage(com.google.api.servicecontrol.v1.LogEntry.parser(), extensionRegistry));
                break;
              }
              case 88: {
                int rawValue = input.readEnum();

                importance_ = rawValue;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (com.google.api.servicecontrol.v1.Operation.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.api.servicecontrol.v1.Operation)
  private static final com.google.api.servicecontrol.v1.Operation DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Operation();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static com.google.api.servicecontrol.v1.Operation getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<Operation> PARSER;

  public static com.google.protobuf.Parser<Operation> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

