// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/container/v1/cluster_service.proto

package com.google.container.v1;

/**
 * <pre>
 * A Google Container Engine cluster.
 * </pre>
 *
 * Protobuf type {@code google.container.v1.Cluster}
 */
public  final class Cluster extends
    com.google.protobuf.GeneratedMessageLite<
        Cluster, Cluster.Builder> implements
    // @@protoc_insertion_point(message_implements:google.container.v1.Cluster)
    ClusterOrBuilder {
  private Cluster() {
    name_ = "";
    description_ = "";
    loggingService_ = "";
    monitoringService_ = "";
    network_ = "";
    clusterIpv4Cidr_ = "";
    subnetwork_ = "";
    nodePools_ = emptyProtobufList();
    locations_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    selfLink_ = "";
    zone_ = "";
    endpoint_ = "";
    initialClusterVersion_ = "";
    currentMasterVersion_ = "";
    currentNodeVersion_ = "";
    createTime_ = "";
    statusMessage_ = "";
    servicesIpv4Cidr_ = "";
    instanceGroupUrls_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    expireTime_ = "";
  }
  /**
   * <pre>
   * The current status of the cluster.
   * </pre>
   *
   * Protobuf enum {@code google.container.v1.Cluster.Status}
   */
  public enum Status
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * Not set.
     * </pre>
     *
     * <code>STATUS_UNSPECIFIED = 0;</code>
     */
    STATUS_UNSPECIFIED(0),
    /**
     * <pre>
     * The PROVISIONING state indicates the cluster is being created.
     * </pre>
     *
     * <code>PROVISIONING = 1;</code>
     */
    PROVISIONING(1),
    /**
     * <pre>
     * The RUNNING state indicates the cluster has been created and is fully
     * usable.
     * </pre>
     *
     * <code>RUNNING = 2;</code>
     */
    RUNNING(2),
    /**
     * <pre>
     * The RECONCILING state indicates that some work is actively being done on
     * the cluster, such as upgrading the master or node software. Details can
     * be found in the `statusMessage` field.
     * </pre>
     *
     * <code>RECONCILING = 3;</code>
     */
    RECONCILING(3),
    /**
     * <pre>
     * The STOPPING state indicates the cluster is being deleted.
     * </pre>
     *
     * <code>STOPPING = 4;</code>
     */
    STOPPING(4),
    /**
     * <pre>
     * The ERROR state indicates the cluster may be unusable. Details
     * can be found in the `statusMessage` field.
     * </pre>
     *
     * <code>ERROR = 5;</code>
     */
    ERROR(5),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Not set.
     * </pre>
     *
     * <code>STATUS_UNSPECIFIED = 0;</code>
     */
    public static final int STATUS_UNSPECIFIED_VALUE = 0;
    /**
     * <pre>
     * The PROVISIONING state indicates the cluster is being created.
     * </pre>
     *
     * <code>PROVISIONING = 1;</code>
     */
    public static final int PROVISIONING_VALUE = 1;
    /**
     * <pre>
     * The RUNNING state indicates the cluster has been created and is fully
     * usable.
     * </pre>
     *
     * <code>RUNNING = 2;</code>
     */
    public static final int RUNNING_VALUE = 2;
    /**
     * <pre>
     * The RECONCILING state indicates that some work is actively being done on
     * the cluster, such as upgrading the master or node software. Details can
     * be found in the `statusMessage` field.
     * </pre>
     *
     * <code>RECONCILING = 3;</code>
     */
    public static final int RECONCILING_VALUE = 3;
    /**
     * <pre>
     * The STOPPING state indicates the cluster is being deleted.
     * </pre>
     *
     * <code>STOPPING = 4;</code>
     */
    public static final int STOPPING_VALUE = 4;
    /**
     * <pre>
     * The ERROR state indicates the cluster may be unusable. Details
     * can be found in the `statusMessage` field.
     * </pre>
     *
     * <code>ERROR = 5;</code>
     */
    public static final int ERROR_VALUE = 5;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Status valueOf(int value) {
      return forNumber(value);
    }

    public static Status forNumber(int value) {
      switch (value) {
        case 0: return STATUS_UNSPECIFIED;
        case 1: return PROVISIONING;
        case 2: return RUNNING;
        case 3: return RECONCILING;
        case 4: return STOPPING;
        case 5: return ERROR;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Status>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Status> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Status>() {
            public Status findValueByNumber(int number) {
              return Status.forNumber(number);
            }
          };

    private final int value;

    private Status(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:google.container.v1.Cluster.Status)
  }

  private int bitField0_;
  public static final int NAME_FIELD_NUMBER = 1;
  private java.lang.String name_;
  /**
   * <pre>
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   * </pre>
   *
   * <code>optional string name = 1;</code>
   */
  public java.lang.String getName() {
    return name_;
  }
  /**
   * <pre>
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   * </pre>
   *
   * <code>optional string name = 1;</code>
   */
  public com.google.protobuf.ByteString
      getNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(name_);
  }
  /**
   * <pre>
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   * </pre>
   *
   * <code>optional string name = 1;</code>
   */
  private void setName(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    name_ = value;
  }
  /**
   * <pre>
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   * </pre>
   *
   * <code>optional string name = 1;</code>
   */
  private void clearName() {
    
    name_ = getDefaultInstance().getName();
  }
  /**
   * <pre>
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   * </pre>
   *
   * <code>optional string name = 1;</code>
   */
  private void setNameBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    name_ = value.toStringUtf8();
  }

  public static final int DESCRIPTION_FIELD_NUMBER = 2;
  private java.lang.String description_;
  /**
   * <pre>
   * An optional description of this cluster.
   * </pre>
   *
   * <code>optional string description = 2;</code>
   */
  public java.lang.String getDescription() {
    return description_;
  }
  /**
   * <pre>
   * An optional description of this cluster.
   * </pre>
   *
   * <code>optional string description = 2;</code>
   */
  public com.google.protobuf.ByteString
      getDescriptionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(description_);
  }
  /**
   * <pre>
   * An optional description of this cluster.
   * </pre>
   *
   * <code>optional string description = 2;</code>
   */
  private void setDescription(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    description_ = value;
  }
  /**
   * <pre>
   * An optional description of this cluster.
   * </pre>
   *
   * <code>optional string description = 2;</code>
   */
  private void clearDescription() {
    
    description_ = getDefaultInstance().getDescription();
  }
  /**
   * <pre>
   * An optional description of this cluster.
   * </pre>
   *
   * <code>optional string description = 2;</code>
   */
  private void setDescriptionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    description_ = value.toStringUtf8();
  }

  public static final int INITIAL_NODE_COUNT_FIELD_NUMBER = 3;
  private int initialNodeCount_;
  /**
   * <pre>
   * The number of nodes to create in this cluster. You must ensure that your
   * Compute Engine &lt;a href="/compute/docs/resource-quotas"&gt;resource quota&lt;/a&gt;
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "node_config") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * </pre>
   *
   * <code>optional int32 initial_node_count = 3;</code>
   */
  public int getInitialNodeCount() {
    return initialNodeCount_;
  }
  /**
   * <pre>
   * The number of nodes to create in this cluster. You must ensure that your
   * Compute Engine &lt;a href="/compute/docs/resource-quotas"&gt;resource quota&lt;/a&gt;
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "node_config") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * </pre>
   *
   * <code>optional int32 initial_node_count = 3;</code>
   */
  private void setInitialNodeCount(int value) {
    
    initialNodeCount_ = value;
  }
  /**
   * <pre>
   * The number of nodes to create in this cluster. You must ensure that your
   * Compute Engine &lt;a href="/compute/docs/resource-quotas"&gt;resource quota&lt;/a&gt;
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "node_config") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * </pre>
   *
   * <code>optional int32 initial_node_count = 3;</code>
   */
  private void clearInitialNodeCount() {
    
    initialNodeCount_ = 0;
  }

  public static final int NODE_CONFIG_FIELD_NUMBER = 4;
  private com.google.container.v1.NodeConfig nodeConfig_;
  /**
   * <pre>
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   * If unspecified, the defaults are used.
   * </pre>
   *
   * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
   */
  public boolean hasNodeConfig() {
    return nodeConfig_ != null;
  }
  /**
   * <pre>
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   * If unspecified, the defaults are used.
   * </pre>
   *
   * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
   */
  public com.google.container.v1.NodeConfig getNodeConfig() {
    return nodeConfig_ == null ? com.google.container.v1.NodeConfig.getDefaultInstance() : nodeConfig_;
  }
  /**
   * <pre>
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   * If unspecified, the defaults are used.
   * </pre>
   *
   * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
   */
  private void setNodeConfig(com.google.container.v1.NodeConfig value) {
    if (value == null) {
      throw new NullPointerException();
    }
    nodeConfig_ = value;
    
    }
  /**
   * <pre>
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   * If unspecified, the defaults are used.
   * </pre>
   *
   * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
   */
  private void setNodeConfig(
      com.google.container.v1.NodeConfig.Builder builderForValue) {
    nodeConfig_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   * If unspecified, the defaults are used.
   * </pre>
   *
   * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
   */
  private void mergeNodeConfig(com.google.container.v1.NodeConfig value) {
    if (nodeConfig_ != null &&
        nodeConfig_ != com.google.container.v1.NodeConfig.getDefaultInstance()) {
      nodeConfig_ =
        com.google.container.v1.NodeConfig.newBuilder(nodeConfig_).mergeFrom(value).buildPartial();
    } else {
      nodeConfig_ = value;
    }
    
  }
  /**
   * <pre>
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   * If unspecified, the defaults are used.
   * </pre>
   *
   * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
   */
  private void clearNodeConfig() {  nodeConfig_ = null;
    
  }

  public static final int MASTER_AUTH_FIELD_NUMBER = 5;
  private com.google.container.v1.MasterAuth masterAuth_;
  /**
   * <pre>
   * The authentication information for accessing the master endpoint.
   * </pre>
   *
   * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
   */
  public boolean hasMasterAuth() {
    return masterAuth_ != null;
  }
  /**
   * <pre>
   * The authentication information for accessing the master endpoint.
   * </pre>
   *
   * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
   */
  public com.google.container.v1.MasterAuth getMasterAuth() {
    return masterAuth_ == null ? com.google.container.v1.MasterAuth.getDefaultInstance() : masterAuth_;
  }
  /**
   * <pre>
   * The authentication information for accessing the master endpoint.
   * </pre>
   *
   * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
   */
  private void setMasterAuth(com.google.container.v1.MasterAuth value) {
    if (value == null) {
      throw new NullPointerException();
    }
    masterAuth_ = value;
    
    }
  /**
   * <pre>
   * The authentication information for accessing the master endpoint.
   * </pre>
   *
   * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
   */
  private void setMasterAuth(
      com.google.container.v1.MasterAuth.Builder builderForValue) {
    masterAuth_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * The authentication information for accessing the master endpoint.
   * </pre>
   *
   * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
   */
  private void mergeMasterAuth(com.google.container.v1.MasterAuth value) {
    if (masterAuth_ != null &&
        masterAuth_ != com.google.container.v1.MasterAuth.getDefaultInstance()) {
      masterAuth_ =
        com.google.container.v1.MasterAuth.newBuilder(masterAuth_).mergeFrom(value).buildPartial();
    } else {
      masterAuth_ = value;
    }
    
  }
  /**
   * <pre>
   * The authentication information for accessing the master endpoint.
   * </pre>
   *
   * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
   */
  private void clearMasterAuth() {  masterAuth_ = null;
    
  }

  public static final int LOGGING_SERVICE_FIELD_NUMBER = 6;
  private java.lang.String loggingService_;
  /**
   * <pre>
   * The logging service the cluster should use to write logs.
   * Currently available options:
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string logging_service = 6;</code>
   */
  public java.lang.String getLoggingService() {
    return loggingService_;
  }
  /**
   * <pre>
   * The logging service the cluster should use to write logs.
   * Currently available options:
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string logging_service = 6;</code>
   */
  public com.google.protobuf.ByteString
      getLoggingServiceBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(loggingService_);
  }
  /**
   * <pre>
   * The logging service the cluster should use to write logs.
   * Currently available options:
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string logging_service = 6;</code>
   */
  private void setLoggingService(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    loggingService_ = value;
  }
  /**
   * <pre>
   * The logging service the cluster should use to write logs.
   * Currently available options:
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string logging_service = 6;</code>
   */
  private void clearLoggingService() {
    
    loggingService_ = getDefaultInstance().getLoggingService();
  }
  /**
   * <pre>
   * The logging service the cluster should use to write logs.
   * Currently available options:
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string logging_service = 6;</code>
   */
  private void setLoggingServiceBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    loggingService_ = value.toStringUtf8();
  }

  public static final int MONITORING_SERVICE_FIELD_NUMBER = 7;
  private java.lang.String monitoringService_;
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string monitoring_service = 7;</code>
   */
  public java.lang.String getMonitoringService() {
    return monitoringService_;
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string monitoring_service = 7;</code>
   */
  public com.google.protobuf.ByteString
      getMonitoringServiceBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(monitoringService_);
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string monitoring_service = 7;</code>
   */
  private void setMonitoringService(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    monitoringService_ = value;
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string monitoring_service = 7;</code>
   */
  private void clearMonitoringService() {
    
    monitoringService_ = getDefaultInstance().getMonitoringService();
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   * </pre>
   *
   * <code>optional string monitoring_service = 7;</code>
   */
  private void setMonitoringServiceBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    monitoringService_ = value.toStringUtf8();
  }

  public static final int NETWORK_FIELD_NUMBER = 8;
  private java.lang.String network_;
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   * </pre>
   *
   * <code>optional string network = 8;</code>
   */
  public java.lang.String getNetwork() {
    return network_;
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   * </pre>
   *
   * <code>optional string network = 8;</code>
   */
  public com.google.protobuf.ByteString
      getNetworkBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(network_);
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   * </pre>
   *
   * <code>optional string network = 8;</code>
   */
  private void setNetwork(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    network_ = value;
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   * </pre>
   *
   * <code>optional string network = 8;</code>
   */
  private void clearNetwork() {
    
    network_ = getDefaultInstance().getNetwork();
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   * </pre>
   *
   * <code>optional string network = 8;</code>
   */
  private void setNetworkBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    network_ = value.toStringUtf8();
  }

  public static final int CLUSTER_IPV4_CIDR_FIELD_NUMBER = 9;
  private java.lang.String clusterIpv4Cidr_;
  /**
   * <pre>
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   * </pre>
   *
   * <code>optional string cluster_ipv4_cidr = 9;</code>
   */
  public java.lang.String getClusterIpv4Cidr() {
    return clusterIpv4Cidr_;
  }
  /**
   * <pre>
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   * </pre>
   *
   * <code>optional string cluster_ipv4_cidr = 9;</code>
   */
  public com.google.protobuf.ByteString
      getClusterIpv4CidrBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(clusterIpv4Cidr_);
  }
  /**
   * <pre>
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   * </pre>
   *
   * <code>optional string cluster_ipv4_cidr = 9;</code>
   */
  private void setClusterIpv4Cidr(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    clusterIpv4Cidr_ = value;
  }
  /**
   * <pre>
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   * </pre>
   *
   * <code>optional string cluster_ipv4_cidr = 9;</code>
   */
  private void clearClusterIpv4Cidr() {
    
    clusterIpv4Cidr_ = getDefaultInstance().getClusterIpv4Cidr();
  }
  /**
   * <pre>
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   * </pre>
   *
   * <code>optional string cluster_ipv4_cidr = 9;</code>
   */
  private void setClusterIpv4CidrBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    clusterIpv4Cidr_ = value.toStringUtf8();
  }

  public static final int ADDONS_CONFIG_FIELD_NUMBER = 10;
  private com.google.container.v1.AddonsConfig addonsConfig_;
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
   */
  public boolean hasAddonsConfig() {
    return addonsConfig_ != null;
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
   */
  public com.google.container.v1.AddonsConfig getAddonsConfig() {
    return addonsConfig_ == null ? com.google.container.v1.AddonsConfig.getDefaultInstance() : addonsConfig_;
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
   */
  private void setAddonsConfig(com.google.container.v1.AddonsConfig value) {
    if (value == null) {
      throw new NullPointerException();
    }
    addonsConfig_ = value;
    
    }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
   */
  private void setAddonsConfig(
      com.google.container.v1.AddonsConfig.Builder builderForValue) {
    addonsConfig_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
   */
  private void mergeAddonsConfig(com.google.container.v1.AddonsConfig value) {
    if (addonsConfig_ != null &&
        addonsConfig_ != com.google.container.v1.AddonsConfig.getDefaultInstance()) {
      addonsConfig_ =
        com.google.container.v1.AddonsConfig.newBuilder(addonsConfig_).mergeFrom(value).buildPartial();
    } else {
      addonsConfig_ = value;
    }
    
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
   */
  private void clearAddonsConfig() {  addonsConfig_ = null;
    
  }

  public static final int SUBNETWORK_FIELD_NUMBER = 11;
  private java.lang.String subnetwork_;
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   * </pre>
   *
   * <code>optional string subnetwork = 11;</code>
   */
  public java.lang.String getSubnetwork() {
    return subnetwork_;
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   * </pre>
   *
   * <code>optional string subnetwork = 11;</code>
   */
  public com.google.protobuf.ByteString
      getSubnetworkBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(subnetwork_);
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   * </pre>
   *
   * <code>optional string subnetwork = 11;</code>
   */
  private void setSubnetwork(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    subnetwork_ = value;
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   * </pre>
   *
   * <code>optional string subnetwork = 11;</code>
   */
  private void clearSubnetwork() {
    
    subnetwork_ = getDefaultInstance().getSubnetwork();
  }
  /**
   * <pre>
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   * </pre>
   *
   * <code>optional string subnetwork = 11;</code>
   */
  private void setSubnetworkBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    subnetwork_ = value.toStringUtf8();
  }

  public static final int NODE_POOLS_FIELD_NUMBER = 12;
  private com.google.protobuf.Internal.ProtobufList<com.google.container.v1.NodePool> nodePools_;
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  public java.util.List<com.google.container.v1.NodePool> getNodePoolsList() {
    return nodePools_;
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  public java.util.List<? extends com.google.container.v1.NodePoolOrBuilder> 
      getNodePoolsOrBuilderList() {
    return nodePools_;
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  public int getNodePoolsCount() {
    return nodePools_.size();
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  public com.google.container.v1.NodePool getNodePools(int index) {
    return nodePools_.get(index);
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  public com.google.container.v1.NodePoolOrBuilder getNodePoolsOrBuilder(
      int index) {
    return nodePools_.get(index);
  }
  private void ensureNodePoolsIsMutable() {
    if (!nodePools_.isModifiable()) {
      nodePools_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(nodePools_);
     }
  }

  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void setNodePools(
      int index, com.google.container.v1.NodePool value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNodePoolsIsMutable();
    nodePools_.set(index, value);
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void setNodePools(
      int index, com.google.container.v1.NodePool.Builder builderForValue) {
    ensureNodePoolsIsMutable();
    nodePools_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void addNodePools(com.google.container.v1.NodePool value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNodePoolsIsMutable();
    nodePools_.add(value);
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void addNodePools(
      int index, com.google.container.v1.NodePool value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNodePoolsIsMutable();
    nodePools_.add(index, value);
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void addNodePools(
      com.google.container.v1.NodePool.Builder builderForValue) {
    ensureNodePoolsIsMutable();
    nodePools_.add(builderForValue.build());
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void addNodePools(
      int index, com.google.container.v1.NodePool.Builder builderForValue) {
    ensureNodePoolsIsMutable();
    nodePools_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void addAllNodePools(
      java.lang.Iterable<? extends com.google.container.v1.NodePool> values) {
    ensureNodePoolsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, nodePools_);
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void clearNodePools() {
    nodePools_ = emptyProtobufList();
  }
  /**
   * <pre>
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   * </pre>
   *
   * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
   */
  private void removeNodePools(int index) {
    ensureNodePoolsIsMutable();
    nodePools_.remove(index);
  }

  public static final int LOCATIONS_FIELD_NUMBER = 13;
  private com.google.protobuf.Internal.ProtobufList<String> locations_;
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  public java.util.List<String> getLocationsList() {
    return locations_;
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  public int getLocationsCount() {
    return locations_.size();
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  public java.lang.String getLocations(int index) {
    return locations_.get(index);
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  public com.google.protobuf.ByteString
      getLocationsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        locations_.get(index));
  }
  private void ensureLocationsIsMutable() {
    if (!locations_.isModifiable()) {
      locations_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(locations_);
     }
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  private void setLocations(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureLocationsIsMutable();
    locations_.set(index, value);
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  private void addLocations(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureLocationsIsMutable();
    locations_.add(value);
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  private void addAllLocations(
      java.lang.Iterable<java.lang.String> values) {
    ensureLocationsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, locations_);
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  private void clearLocations() {
    locations_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   * </pre>
   *
   * <code>repeated string locations = 13;</code>
   */
  private void addLocationsBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureLocationsIsMutable();
    locations_.add(value.toStringUtf8());
  }

  public static final int ENABLE_KUBERNETES_ALPHA_FIELD_NUMBER = 14;
  private boolean enableKubernetesAlpha_;
  /**
   * <pre>
   * Kubernetes alpha features are enabled on this cluster. This includes alpha
   * API groups (e.g. v1alpha1) and features that may not be production ready in
   * the kubernetes version of the master and nodes.
   * The cluster has no SLA for uptime and master/node upgrades are disabled.
   * Alpha enabled clusters are automatically deleted thirty days after
   * creation.
   * </pre>
   *
   * <code>optional bool enable_kubernetes_alpha = 14;</code>
   */
  public boolean getEnableKubernetesAlpha() {
    return enableKubernetesAlpha_;
  }
  /**
   * <pre>
   * Kubernetes alpha features are enabled on this cluster. This includes alpha
   * API groups (e.g. v1alpha1) and features that may not be production ready in
   * the kubernetes version of the master and nodes.
   * The cluster has no SLA for uptime and master/node upgrades are disabled.
   * Alpha enabled clusters are automatically deleted thirty days after
   * creation.
   * </pre>
   *
   * <code>optional bool enable_kubernetes_alpha = 14;</code>
   */
  private void setEnableKubernetesAlpha(boolean value) {
    
    enableKubernetesAlpha_ = value;
  }
  /**
   * <pre>
   * Kubernetes alpha features are enabled on this cluster. This includes alpha
   * API groups (e.g. v1alpha1) and features that may not be production ready in
   * the kubernetes version of the master and nodes.
   * The cluster has no SLA for uptime and master/node upgrades are disabled.
   * Alpha enabled clusters are automatically deleted thirty days after
   * creation.
   * </pre>
   *
   * <code>optional bool enable_kubernetes_alpha = 14;</code>
   */
  private void clearEnableKubernetesAlpha() {
    
    enableKubernetesAlpha_ = false;
  }

  public static final int SELF_LINK_FIELD_NUMBER = 100;
  private java.lang.String selfLink_;
  /**
   * <pre>
   * [Output only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>optional string self_link = 100;</code>
   */
  public java.lang.String getSelfLink() {
    return selfLink_;
  }
  /**
   * <pre>
   * [Output only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>optional string self_link = 100;</code>
   */
  public com.google.protobuf.ByteString
      getSelfLinkBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(selfLink_);
  }
  /**
   * <pre>
   * [Output only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>optional string self_link = 100;</code>
   */
  private void setSelfLink(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    selfLink_ = value;
  }
  /**
   * <pre>
   * [Output only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>optional string self_link = 100;</code>
   */
  private void clearSelfLink() {
    
    selfLink_ = getDefaultInstance().getSelfLink();
  }
  /**
   * <pre>
   * [Output only] Server-defined URL for the resource.
   * </pre>
   *
   * <code>optional string self_link = 100;</code>
   */
  private void setSelfLinkBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    selfLink_ = value.toStringUtf8();
  }

  public static final int ZONE_FIELD_NUMBER = 101;
  private java.lang.String zone_;
  /**
   * <pre>
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * </pre>
   *
   * <code>optional string zone = 101;</code>
   */
  public java.lang.String getZone() {
    return zone_;
  }
  /**
   * <pre>
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * </pre>
   *
   * <code>optional string zone = 101;</code>
   */
  public com.google.protobuf.ByteString
      getZoneBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(zone_);
  }
  /**
   * <pre>
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * </pre>
   *
   * <code>optional string zone = 101;</code>
   */
  private void setZone(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    zone_ = value;
  }
  /**
   * <pre>
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * </pre>
   *
   * <code>optional string zone = 101;</code>
   */
  private void clearZone() {
    
    zone_ = getDefaultInstance().getZone();
  }
  /**
   * <pre>
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * </pre>
   *
   * <code>optional string zone = 101;</code>
   */
  private void setZoneBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    zone_ = value.toStringUtf8();
  }

  public static final int ENDPOINT_FIELD_NUMBER = 102;
  private java.lang.String endpoint_;
  /**
   * <pre>
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password&#64;endpoint/`.
   * See the `masterAuth` property of this resource for username and
   * password information.
   * </pre>
   *
   * <code>optional string endpoint = 102;</code>
   */
  public java.lang.String getEndpoint() {
    return endpoint_;
  }
  /**
   * <pre>
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password&#64;endpoint/`.
   * See the `masterAuth` property of this resource for username and
   * password information.
   * </pre>
   *
   * <code>optional string endpoint = 102;</code>
   */
  public com.google.protobuf.ByteString
      getEndpointBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(endpoint_);
  }
  /**
   * <pre>
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password&#64;endpoint/`.
   * See the `masterAuth` property of this resource for username and
   * password information.
   * </pre>
   *
   * <code>optional string endpoint = 102;</code>
   */
  private void setEndpoint(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    endpoint_ = value;
  }
  /**
   * <pre>
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password&#64;endpoint/`.
   * See the `masterAuth` property of this resource for username and
   * password information.
   * </pre>
   *
   * <code>optional string endpoint = 102;</code>
   */
  private void clearEndpoint() {
    
    endpoint_ = getDefaultInstance().getEndpoint();
  }
  /**
   * <pre>
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password&#64;endpoint/`.
   * See the `masterAuth` property of this resource for username and
   * password information.
   * </pre>
   *
   * <code>optional string endpoint = 102;</code>
   */
  private void setEndpointBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    endpoint_ = value.toStringUtf8();
  }

  public static final int INITIAL_CLUSTER_VERSION_FIELD_NUMBER = 103;
  private java.lang.String initialClusterVersion_;
  /**
   * <pre>
   * [Output only] The software version of the master endpoint and kubelets used
   * in the cluster when it was first created. The version can be upgraded over
   * time.
   * </pre>
   *
   * <code>optional string initial_cluster_version = 103;</code>
   */
  public java.lang.String getInitialClusterVersion() {
    return initialClusterVersion_;
  }
  /**
   * <pre>
   * [Output only] The software version of the master endpoint and kubelets used
   * in the cluster when it was first created. The version can be upgraded over
   * time.
   * </pre>
   *
   * <code>optional string initial_cluster_version = 103;</code>
   */
  public com.google.protobuf.ByteString
      getInitialClusterVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(initialClusterVersion_);
  }
  /**
   * <pre>
   * [Output only] The software version of the master endpoint and kubelets used
   * in the cluster when it was first created. The version can be upgraded over
   * time.
   * </pre>
   *
   * <code>optional string initial_cluster_version = 103;</code>
   */
  private void setInitialClusterVersion(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    initialClusterVersion_ = value;
  }
  /**
   * <pre>
   * [Output only] The software version of the master endpoint and kubelets used
   * in the cluster when it was first created. The version can be upgraded over
   * time.
   * </pre>
   *
   * <code>optional string initial_cluster_version = 103;</code>
   */
  private void clearInitialClusterVersion() {
    
    initialClusterVersion_ = getDefaultInstance().getInitialClusterVersion();
  }
  /**
   * <pre>
   * [Output only] The software version of the master endpoint and kubelets used
   * in the cluster when it was first created. The version can be upgraded over
   * time.
   * </pre>
   *
   * <code>optional string initial_cluster_version = 103;</code>
   */
  private void setInitialClusterVersionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    initialClusterVersion_ = value.toStringUtf8();
  }

  public static final int CURRENT_MASTER_VERSION_FIELD_NUMBER = 104;
  private java.lang.String currentMasterVersion_;
  /**
   * <pre>
   * [Output only] The current software version of the master endpoint.
   * </pre>
   *
   * <code>optional string current_master_version = 104;</code>
   */
  public java.lang.String getCurrentMasterVersion() {
    return currentMasterVersion_;
  }
  /**
   * <pre>
   * [Output only] The current software version of the master endpoint.
   * </pre>
   *
   * <code>optional string current_master_version = 104;</code>
   */
  public com.google.protobuf.ByteString
      getCurrentMasterVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(currentMasterVersion_);
  }
  /**
   * <pre>
   * [Output only] The current software version of the master endpoint.
   * </pre>
   *
   * <code>optional string current_master_version = 104;</code>
   */
  private void setCurrentMasterVersion(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    currentMasterVersion_ = value;
  }
  /**
   * <pre>
   * [Output only] The current software version of the master endpoint.
   * </pre>
   *
   * <code>optional string current_master_version = 104;</code>
   */
  private void clearCurrentMasterVersion() {
    
    currentMasterVersion_ = getDefaultInstance().getCurrentMasterVersion();
  }
  /**
   * <pre>
   * [Output only] The current software version of the master endpoint.
   * </pre>
   *
   * <code>optional string current_master_version = 104;</code>
   */
  private void setCurrentMasterVersionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    currentMasterVersion_ = value.toStringUtf8();
  }

  public static final int CURRENT_NODE_VERSION_FIELD_NUMBER = 105;
  private java.lang.String currentNodeVersion_;
  /**
   * <pre>
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   * </pre>
   *
   * <code>optional string current_node_version = 105;</code>
   */
  public java.lang.String getCurrentNodeVersion() {
    return currentNodeVersion_;
  }
  /**
   * <pre>
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   * </pre>
   *
   * <code>optional string current_node_version = 105;</code>
   */
  public com.google.protobuf.ByteString
      getCurrentNodeVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(currentNodeVersion_);
  }
  /**
   * <pre>
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   * </pre>
   *
   * <code>optional string current_node_version = 105;</code>
   */
  private void setCurrentNodeVersion(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    currentNodeVersion_ = value;
  }
  /**
   * <pre>
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   * </pre>
   *
   * <code>optional string current_node_version = 105;</code>
   */
  private void clearCurrentNodeVersion() {
    
    currentNodeVersion_ = getDefaultInstance().getCurrentNodeVersion();
  }
  /**
   * <pre>
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   * </pre>
   *
   * <code>optional string current_node_version = 105;</code>
   */
  private void setCurrentNodeVersionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    currentNodeVersion_ = value.toStringUtf8();
  }

  public static final int CREATE_TIME_FIELD_NUMBER = 106;
  private java.lang.String createTime_;
  /**
   * <pre>
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string create_time = 106;</code>
   */
  public java.lang.String getCreateTime() {
    return createTime_;
  }
  /**
   * <pre>
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string create_time = 106;</code>
   */
  public com.google.protobuf.ByteString
      getCreateTimeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(createTime_);
  }
  /**
   * <pre>
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string create_time = 106;</code>
   */
  private void setCreateTime(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    createTime_ = value;
  }
  /**
   * <pre>
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string create_time = 106;</code>
   */
  private void clearCreateTime() {
    
    createTime_ = getDefaultInstance().getCreateTime();
  }
  /**
   * <pre>
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string create_time = 106;</code>
   */
  private void setCreateTimeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    createTime_ = value.toStringUtf8();
  }

  public static final int STATUS_FIELD_NUMBER = 107;
  private int status_;
  /**
   * <pre>
   * [Output only] The current status of this cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
   */
  public int getStatusValue() {
    return status_;
  }
  /**
   * <pre>
   * [Output only] The current status of this cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
   */
  public com.google.container.v1.Cluster.Status getStatus() {
    com.google.container.v1.Cluster.Status result = com.google.container.v1.Cluster.Status.forNumber(status_);
    return result == null ? com.google.container.v1.Cluster.Status.UNRECOGNIZED : result;
  }
  /**
   * <pre>
   * [Output only] The current status of this cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
   */
  private void setStatusValue(int value) {
      status_ = value;
  }
  /**
   * <pre>
   * [Output only] The current status of this cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
   */
  private void setStatus(com.google.container.v1.Cluster.Status value) {
    if (value == null) {
      throw new NullPointerException();
    }
    
    status_ = value.getNumber();
  }
  /**
   * <pre>
   * [Output only] The current status of this cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
   */
  private void clearStatus() {
    
    status_ = 0;
  }

  public static final int STATUS_MESSAGE_FIELD_NUMBER = 108;
  private java.lang.String statusMessage_;
  /**
   * <pre>
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   * </pre>
   *
   * <code>optional string status_message = 108;</code>
   */
  public java.lang.String getStatusMessage() {
    return statusMessage_;
  }
  /**
   * <pre>
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   * </pre>
   *
   * <code>optional string status_message = 108;</code>
   */
  public com.google.protobuf.ByteString
      getStatusMessageBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(statusMessage_);
  }
  /**
   * <pre>
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   * </pre>
   *
   * <code>optional string status_message = 108;</code>
   */
  private void setStatusMessage(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    statusMessage_ = value;
  }
  /**
   * <pre>
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   * </pre>
   *
   * <code>optional string status_message = 108;</code>
   */
  private void clearStatusMessage() {
    
    statusMessage_ = getDefaultInstance().getStatusMessage();
  }
  /**
   * <pre>
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   * </pre>
   *
   * <code>optional string status_message = 108;</code>
   */
  private void setStatusMessageBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    statusMessage_ = value.toStringUtf8();
  }

  public static final int NODE_IPV4_CIDR_SIZE_FIELD_NUMBER = 109;
  private int nodeIpv4CidrSize_;
  /**
   * <pre>
   * [Output only] The size of the address space on each node for hosting
   * containers. This is provisioned from within the `container_ipv4_cidr`
   * range.
   * </pre>
   *
   * <code>optional int32 node_ipv4_cidr_size = 109;</code>
   */
  public int getNodeIpv4CidrSize() {
    return nodeIpv4CidrSize_;
  }
  /**
   * <pre>
   * [Output only] The size of the address space on each node for hosting
   * containers. This is provisioned from within the `container_ipv4_cidr`
   * range.
   * </pre>
   *
   * <code>optional int32 node_ipv4_cidr_size = 109;</code>
   */
  private void setNodeIpv4CidrSize(int value) {
    
    nodeIpv4CidrSize_ = value;
  }
  /**
   * <pre>
   * [Output only] The size of the address space on each node for hosting
   * containers. This is provisioned from within the `container_ipv4_cidr`
   * range.
   * </pre>
   *
   * <code>optional int32 node_ipv4_cidr_size = 109;</code>
   */
  private void clearNodeIpv4CidrSize() {
    
    nodeIpv4CidrSize_ = 0;
  }

  public static final int SERVICES_IPV4_CIDR_FIELD_NUMBER = 110;
  private java.lang.String servicesIpv4Cidr_;
  /**
   * <pre>
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   * </pre>
   *
   * <code>optional string services_ipv4_cidr = 110;</code>
   */
  public java.lang.String getServicesIpv4Cidr() {
    return servicesIpv4Cidr_;
  }
  /**
   * <pre>
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   * </pre>
   *
   * <code>optional string services_ipv4_cidr = 110;</code>
   */
  public com.google.protobuf.ByteString
      getServicesIpv4CidrBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(servicesIpv4Cidr_);
  }
  /**
   * <pre>
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   * </pre>
   *
   * <code>optional string services_ipv4_cidr = 110;</code>
   */
  private void setServicesIpv4Cidr(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    servicesIpv4Cidr_ = value;
  }
  /**
   * <pre>
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   * </pre>
   *
   * <code>optional string services_ipv4_cidr = 110;</code>
   */
  private void clearServicesIpv4Cidr() {
    
    servicesIpv4Cidr_ = getDefaultInstance().getServicesIpv4Cidr();
  }
  /**
   * <pre>
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   * </pre>
   *
   * <code>optional string services_ipv4_cidr = 110;</code>
   */
  private void setServicesIpv4CidrBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    servicesIpv4Cidr_ = value.toStringUtf8();
  }

  public static final int INSTANCE_GROUP_URLS_FIELD_NUMBER = 111;
  private com.google.protobuf.Internal.ProtobufList<String> instanceGroupUrls_;
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  public java.util.List<String> getInstanceGroupUrlsList() {
    return instanceGroupUrls_;
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  public int getInstanceGroupUrlsCount() {
    return instanceGroupUrls_.size();
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  public java.lang.String getInstanceGroupUrls(int index) {
    return instanceGroupUrls_.get(index);
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  public com.google.protobuf.ByteString
      getInstanceGroupUrlsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        instanceGroupUrls_.get(index));
  }
  private void ensureInstanceGroupUrlsIsMutable() {
    if (!instanceGroupUrls_.isModifiable()) {
      instanceGroupUrls_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(instanceGroupUrls_);
     }
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  private void setInstanceGroupUrls(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureInstanceGroupUrlsIsMutable();
    instanceGroupUrls_.set(index, value);
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  private void addInstanceGroupUrls(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureInstanceGroupUrlsIsMutable();
    instanceGroupUrls_.add(value);
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  private void addAllInstanceGroupUrls(
      java.lang.Iterable<java.lang.String> values) {
    ensureInstanceGroupUrlsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, instanceGroupUrls_);
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  private void clearInstanceGroupUrls() {
    instanceGroupUrls_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   * </pre>
   *
   * <code>repeated string instance_group_urls = 111;</code>
   */
  private void addInstanceGroupUrlsBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureInstanceGroupUrlsIsMutable();
    instanceGroupUrls_.add(value.toStringUtf8());
  }

  public static final int CURRENT_NODE_COUNT_FIELD_NUMBER = 112;
  private int currentNodeCount_;
  /**
   * <pre>
   * [Output only] The number of nodes currently in the cluster.
   * </pre>
   *
   * <code>optional int32 current_node_count = 112;</code>
   */
  public int getCurrentNodeCount() {
    return currentNodeCount_;
  }
  /**
   * <pre>
   * [Output only] The number of nodes currently in the cluster.
   * </pre>
   *
   * <code>optional int32 current_node_count = 112;</code>
   */
  private void setCurrentNodeCount(int value) {
    
    currentNodeCount_ = value;
  }
  /**
   * <pre>
   * [Output only] The number of nodes currently in the cluster.
   * </pre>
   *
   * <code>optional int32 current_node_count = 112;</code>
   */
  private void clearCurrentNodeCount() {
    
    currentNodeCount_ = 0;
  }

  public static final int EXPIRE_TIME_FIELD_NUMBER = 113;
  private java.lang.String expireTime_;
  /**
   * <pre>
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string expire_time = 113;</code>
   */
  public java.lang.String getExpireTime() {
    return expireTime_;
  }
  /**
   * <pre>
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string expire_time = 113;</code>
   */
  public com.google.protobuf.ByteString
      getExpireTimeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(expireTime_);
  }
  /**
   * <pre>
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string expire_time = 113;</code>
   */
  private void setExpireTime(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    expireTime_ = value;
  }
  /**
   * <pre>
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string expire_time = 113;</code>
   */
  private void clearExpireTime() {
    
    expireTime_ = getDefaultInstance().getExpireTime();
  }
  /**
   * <pre>
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   * </pre>
   *
   * <code>optional string expire_time = 113;</code>
   */
  private void setExpireTimeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    expireTime_ = value.toStringUtf8();
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!name_.isEmpty()) {
      output.writeString(1, getName());
    }
    if (!description_.isEmpty()) {
      output.writeString(2, getDescription());
    }
    if (initialNodeCount_ != 0) {
      output.writeInt32(3, initialNodeCount_);
    }
    if (nodeConfig_ != null) {
      output.writeMessage(4, getNodeConfig());
    }
    if (masterAuth_ != null) {
      output.writeMessage(5, getMasterAuth());
    }
    if (!loggingService_.isEmpty()) {
      output.writeString(6, getLoggingService());
    }
    if (!monitoringService_.isEmpty()) {
      output.writeString(7, getMonitoringService());
    }
    if (!network_.isEmpty()) {
      output.writeString(8, getNetwork());
    }
    if (!clusterIpv4Cidr_.isEmpty()) {
      output.writeString(9, getClusterIpv4Cidr());
    }
    if (addonsConfig_ != null) {
      output.writeMessage(10, getAddonsConfig());
    }
    if (!subnetwork_.isEmpty()) {
      output.writeString(11, getSubnetwork());
    }
    for (int i = 0; i < nodePools_.size(); i++) {
      output.writeMessage(12, nodePools_.get(i));
    }
    for (int i = 0; i < locations_.size(); i++) {
      output.writeString(13, locations_.get(i));
    }
    if (enableKubernetesAlpha_ != false) {
      output.writeBool(14, enableKubernetesAlpha_);
    }
    if (!selfLink_.isEmpty()) {
      output.writeString(100, getSelfLink());
    }
    if (!zone_.isEmpty()) {
      output.writeString(101, getZone());
    }
    if (!endpoint_.isEmpty()) {
      output.writeString(102, getEndpoint());
    }
    if (!initialClusterVersion_.isEmpty()) {
      output.writeString(103, getInitialClusterVersion());
    }
    if (!currentMasterVersion_.isEmpty()) {
      output.writeString(104, getCurrentMasterVersion());
    }
    if (!currentNodeVersion_.isEmpty()) {
      output.writeString(105, getCurrentNodeVersion());
    }
    if (!createTime_.isEmpty()) {
      output.writeString(106, getCreateTime());
    }
    if (status_ != com.google.container.v1.Cluster.Status.STATUS_UNSPECIFIED.getNumber()) {
      output.writeEnum(107, status_);
    }
    if (!statusMessage_.isEmpty()) {
      output.writeString(108, getStatusMessage());
    }
    if (nodeIpv4CidrSize_ != 0) {
      output.writeInt32(109, nodeIpv4CidrSize_);
    }
    if (!servicesIpv4Cidr_.isEmpty()) {
      output.writeString(110, getServicesIpv4Cidr());
    }
    for (int i = 0; i < instanceGroupUrls_.size(); i++) {
      output.writeString(111, instanceGroupUrls_.get(i));
    }
    if (currentNodeCount_ != 0) {
      output.writeInt32(112, currentNodeCount_);
    }
    if (!expireTime_.isEmpty()) {
      output.writeString(113, getExpireTime());
    }
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (!name_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(1, getName());
    }
    if (!description_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(2, getDescription());
    }
    if (initialNodeCount_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(3, initialNodeCount_);
    }
    if (nodeConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(4, getNodeConfig());
    }
    if (masterAuth_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, getMasterAuth());
    }
    if (!loggingService_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(6, getLoggingService());
    }
    if (!monitoringService_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(7, getMonitoringService());
    }
    if (!network_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(8, getNetwork());
    }
    if (!clusterIpv4Cidr_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(9, getClusterIpv4Cidr());
    }
    if (addonsConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(10, getAddonsConfig());
    }
    if (!subnetwork_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(11, getSubnetwork());
    }
    for (int i = 0; i < nodePools_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(12, nodePools_.get(i));
    }
    {
      int dataSize = 0;
      for (int i = 0; i < locations_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(locations_.get(i));
      }
      size += dataSize;
      size += 1 * getLocationsList().size();
    }
    if (enableKubernetesAlpha_ != false) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(14, enableKubernetesAlpha_);
    }
    if (!selfLink_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(100, getSelfLink());
    }
    if (!zone_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(101, getZone());
    }
    if (!endpoint_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(102, getEndpoint());
    }
    if (!initialClusterVersion_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(103, getInitialClusterVersion());
    }
    if (!currentMasterVersion_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(104, getCurrentMasterVersion());
    }
    if (!currentNodeVersion_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(105, getCurrentNodeVersion());
    }
    if (!createTime_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(106, getCreateTime());
    }
    if (status_ != com.google.container.v1.Cluster.Status.STATUS_UNSPECIFIED.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(107, status_);
    }
    if (!statusMessage_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(108, getStatusMessage());
    }
    if (nodeIpv4CidrSize_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(109, nodeIpv4CidrSize_);
    }
    if (!servicesIpv4Cidr_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(110, getServicesIpv4Cidr());
    }
    {
      int dataSize = 0;
      for (int i = 0; i < instanceGroupUrls_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(instanceGroupUrls_.get(i));
      }
      size += dataSize;
      size += 2 * getInstanceGroupUrlsList().size();
    }
    if (currentNodeCount_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(112, currentNodeCount_);
    }
    if (!expireTime_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(113, getExpireTime());
    }
    memoizedSerializedSize = size;
    return size;
  }

  public static com.google.container.v1.Cluster parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.container.v1.Cluster parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.container.v1.Cluster parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.container.v1.Cluster parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.container.v1.Cluster parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.Cluster parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.container.v1.Cluster parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.Cluster parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.container.v1.Cluster parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.Cluster parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.container.v1.Cluster prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * A Google Container Engine cluster.
   * </pre>
   *
   * Protobuf type {@code google.container.v1.Cluster}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.container.v1.Cluster, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.container.v1.Cluster)
      com.google.container.v1.ClusterOrBuilder {
    // Construct using com.google.container.v1.Cluster.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The name of this cluster. The name must be unique within this project
     * and zone, and can be up to 40 characters with the following restrictions:
     * * Lowercase letters, numbers, and hyphens only.
     * * Must start with a letter.
     * * Must end with a number or a letter.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public java.lang.String getName() {
      return instance.getName();
    }
    /**
     * <pre>
     * The name of this cluster. The name must be unique within this project
     * and zone, and can be up to 40 characters with the following restrictions:
     * * Lowercase letters, numbers, and hyphens only.
     * * Must start with a letter.
     * * Must end with a number or a letter.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      return instance.getNameBytes();
    }
    /**
     * <pre>
     * The name of this cluster. The name must be unique within this project
     * and zone, and can be up to 40 characters with the following restrictions:
     * * Lowercase letters, numbers, and hyphens only.
     * * Must start with a letter.
     * * Must end with a number or a letter.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public Builder setName(
        java.lang.String value) {
      copyOnWrite();
      instance.setName(value);
      return this;
    }
    /**
     * <pre>
     * The name of this cluster. The name must be unique within this project
     * and zone, and can be up to 40 characters with the following restrictions:
     * * Lowercase letters, numbers, and hyphens only.
     * * Must start with a letter.
     * * Must end with a number or a letter.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public Builder clearName() {
      copyOnWrite();
      instance.clearName();
      return this;
    }
    /**
     * <pre>
     * The name of this cluster. The name must be unique within this project
     * and zone, and can be up to 40 characters with the following restrictions:
     * * Lowercase letters, numbers, and hyphens only.
     * * Must start with a letter.
     * * Must end with a number or a letter.
     * </pre>
     *
     * <code>optional string name = 1;</code>
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * An optional description of this cluster.
     * </pre>
     *
     * <code>optional string description = 2;</code>
     */
    public java.lang.String getDescription() {
      return instance.getDescription();
    }
    /**
     * <pre>
     * An optional description of this cluster.
     * </pre>
     *
     * <code>optional string description = 2;</code>
     */
    public com.google.protobuf.ByteString
        getDescriptionBytes() {
      return instance.getDescriptionBytes();
    }
    /**
     * <pre>
     * An optional description of this cluster.
     * </pre>
     *
     * <code>optional string description = 2;</code>
     */
    public Builder setDescription(
        java.lang.String value) {
      copyOnWrite();
      instance.setDescription(value);
      return this;
    }
    /**
     * <pre>
     * An optional description of this cluster.
     * </pre>
     *
     * <code>optional string description = 2;</code>
     */
    public Builder clearDescription() {
      copyOnWrite();
      instance.clearDescription();
      return this;
    }
    /**
     * <pre>
     * An optional description of this cluster.
     * </pre>
     *
     * <code>optional string description = 2;</code>
     */
    public Builder setDescriptionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDescriptionBytes(value);
      return this;
    }

    /**
     * <pre>
     * The number of nodes to create in this cluster. You must ensure that your
     * Compute Engine &lt;a href="/compute/docs/resource-quotas"&gt;resource quota&lt;/a&gt;
     * is sufficient for this number of instances. You must also have available
     * firewall and routes quota.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "node_config") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * </pre>
     *
     * <code>optional int32 initial_node_count = 3;</code>
     */
    public int getInitialNodeCount() {
      return instance.getInitialNodeCount();
    }
    /**
     * <pre>
     * The number of nodes to create in this cluster. You must ensure that your
     * Compute Engine &lt;a href="/compute/docs/resource-quotas"&gt;resource quota&lt;/a&gt;
     * is sufficient for this number of instances. You must also have available
     * firewall and routes quota.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "node_config") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * </pre>
     *
     * <code>optional int32 initial_node_count = 3;</code>
     */
    public Builder setInitialNodeCount(int value) {
      copyOnWrite();
      instance.setInitialNodeCount(value);
      return this;
    }
    /**
     * <pre>
     * The number of nodes to create in this cluster. You must ensure that your
     * Compute Engine &lt;a href="/compute/docs/resource-quotas"&gt;resource quota&lt;/a&gt;
     * is sufficient for this number of instances. You must also have available
     * firewall and routes quota.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "node_config") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * </pre>
     *
     * <code>optional int32 initial_node_count = 3;</code>
     */
    public Builder clearInitialNodeCount() {
      copyOnWrite();
      instance.clearInitialNodeCount();
      return this;
    }

    /**
     * <pre>
     * Parameters used in creating the cluster's nodes.
     * See `nodeConfig` for the description of its properties.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "initial_node_count") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * For responses, this field will be populated with the node configuration of
     * the first node pool.
     * If unspecified, the defaults are used.
     * </pre>
     *
     * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
     */
    public boolean hasNodeConfig() {
      return instance.hasNodeConfig();
    }
    /**
     * <pre>
     * Parameters used in creating the cluster's nodes.
     * See `nodeConfig` for the description of its properties.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "initial_node_count") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * For responses, this field will be populated with the node configuration of
     * the first node pool.
     * If unspecified, the defaults are used.
     * </pre>
     *
     * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
     */
    public com.google.container.v1.NodeConfig getNodeConfig() {
      return instance.getNodeConfig();
    }
    /**
     * <pre>
     * Parameters used in creating the cluster's nodes.
     * See `nodeConfig` for the description of its properties.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "initial_node_count") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * For responses, this field will be populated with the node configuration of
     * the first node pool.
     * If unspecified, the defaults are used.
     * </pre>
     *
     * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
     */
    public Builder setNodeConfig(com.google.container.v1.NodeConfig value) {
      copyOnWrite();
      instance.setNodeConfig(value);
      return this;
      }
    /**
     * <pre>
     * Parameters used in creating the cluster's nodes.
     * See `nodeConfig` for the description of its properties.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "initial_node_count") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * For responses, this field will be populated with the node configuration of
     * the first node pool.
     * If unspecified, the defaults are used.
     * </pre>
     *
     * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
     */
    public Builder setNodeConfig(
        com.google.container.v1.NodeConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setNodeConfig(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Parameters used in creating the cluster's nodes.
     * See `nodeConfig` for the description of its properties.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "initial_node_count") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * For responses, this field will be populated with the node configuration of
     * the first node pool.
     * If unspecified, the defaults are used.
     * </pre>
     *
     * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
     */
    public Builder mergeNodeConfig(com.google.container.v1.NodeConfig value) {
      copyOnWrite();
      instance.mergeNodeConfig(value);
      return this;
    }
    /**
     * <pre>
     * Parameters used in creating the cluster's nodes.
     * See `nodeConfig` for the description of its properties.
     * For requests, this field should only be used in lieu of a
     * "node_pool" object, since this configuration (along with the
     * "initial_node_count") will be used to create a "NodePool" object with an
     * auto-generated name. Do not use this and a node_pool at the same time.
     * For responses, this field will be populated with the node configuration of
     * the first node pool.
     * If unspecified, the defaults are used.
     * </pre>
     *
     * <code>optional .google.container.v1.NodeConfig node_config = 4;</code>
     */
    public Builder clearNodeConfig() {  copyOnWrite();
      instance.clearNodeConfig();
      return this;
    }

    /**
     * <pre>
     * The authentication information for accessing the master endpoint.
     * </pre>
     *
     * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
     */
    public boolean hasMasterAuth() {
      return instance.hasMasterAuth();
    }
    /**
     * <pre>
     * The authentication information for accessing the master endpoint.
     * </pre>
     *
     * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
     */
    public com.google.container.v1.MasterAuth getMasterAuth() {
      return instance.getMasterAuth();
    }
    /**
     * <pre>
     * The authentication information for accessing the master endpoint.
     * </pre>
     *
     * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
     */
    public Builder setMasterAuth(com.google.container.v1.MasterAuth value) {
      copyOnWrite();
      instance.setMasterAuth(value);
      return this;
      }
    /**
     * <pre>
     * The authentication information for accessing the master endpoint.
     * </pre>
     *
     * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
     */
    public Builder setMasterAuth(
        com.google.container.v1.MasterAuth.Builder builderForValue) {
      copyOnWrite();
      instance.setMasterAuth(builderForValue);
      return this;
    }
    /**
     * <pre>
     * The authentication information for accessing the master endpoint.
     * </pre>
     *
     * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
     */
    public Builder mergeMasterAuth(com.google.container.v1.MasterAuth value) {
      copyOnWrite();
      instance.mergeMasterAuth(value);
      return this;
    }
    /**
     * <pre>
     * The authentication information for accessing the master endpoint.
     * </pre>
     *
     * <code>optional .google.container.v1.MasterAuth master_auth = 5;</code>
     */
    public Builder clearMasterAuth() {  copyOnWrite();
      instance.clearMasterAuth();
      return this;
    }

    /**
     * <pre>
     * The logging service the cluster should use to write logs.
     * Currently available options:
     * * `logging.googleapis.com` - the Google Cloud Logging service.
     * * `none` - no logs will be exported from the cluster.
     * * if left as an empty string,`logging.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string logging_service = 6;</code>
     */
    public java.lang.String getLoggingService() {
      return instance.getLoggingService();
    }
    /**
     * <pre>
     * The logging service the cluster should use to write logs.
     * Currently available options:
     * * `logging.googleapis.com` - the Google Cloud Logging service.
     * * `none` - no logs will be exported from the cluster.
     * * if left as an empty string,`logging.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string logging_service = 6;</code>
     */
    public com.google.protobuf.ByteString
        getLoggingServiceBytes() {
      return instance.getLoggingServiceBytes();
    }
    /**
     * <pre>
     * The logging service the cluster should use to write logs.
     * Currently available options:
     * * `logging.googleapis.com` - the Google Cloud Logging service.
     * * `none` - no logs will be exported from the cluster.
     * * if left as an empty string,`logging.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string logging_service = 6;</code>
     */
    public Builder setLoggingService(
        java.lang.String value) {
      copyOnWrite();
      instance.setLoggingService(value);
      return this;
    }
    /**
     * <pre>
     * The logging service the cluster should use to write logs.
     * Currently available options:
     * * `logging.googleapis.com` - the Google Cloud Logging service.
     * * `none` - no logs will be exported from the cluster.
     * * if left as an empty string,`logging.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string logging_service = 6;</code>
     */
    public Builder clearLoggingService() {
      copyOnWrite();
      instance.clearLoggingService();
      return this;
    }
    /**
     * <pre>
     * The logging service the cluster should use to write logs.
     * Currently available options:
     * * `logging.googleapis.com` - the Google Cloud Logging service.
     * * `none` - no logs will be exported from the cluster.
     * * if left as an empty string,`logging.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string logging_service = 6;</code>
     */
    public Builder setLoggingServiceBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLoggingServiceBytes(value);
      return this;
    }

    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
     * * `none` - no metrics will be exported from the cluster.
     * * if left as an empty string, `monitoring.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string monitoring_service = 7;</code>
     */
    public java.lang.String getMonitoringService() {
      return instance.getMonitoringService();
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
     * * `none` - no metrics will be exported from the cluster.
     * * if left as an empty string, `monitoring.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string monitoring_service = 7;</code>
     */
    public com.google.protobuf.ByteString
        getMonitoringServiceBytes() {
      return instance.getMonitoringServiceBytes();
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
     * * `none` - no metrics will be exported from the cluster.
     * * if left as an empty string, `monitoring.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string monitoring_service = 7;</code>
     */
    public Builder setMonitoringService(
        java.lang.String value) {
      copyOnWrite();
      instance.setMonitoringService(value);
      return this;
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
     * * `none` - no metrics will be exported from the cluster.
     * * if left as an empty string, `monitoring.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string monitoring_service = 7;</code>
     */
    public Builder clearMonitoringService() {
      copyOnWrite();
      instance.clearMonitoringService();
      return this;
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
     * * `none` - no metrics will be exported from the cluster.
     * * if left as an empty string, `monitoring.googleapis.com` will be used.
     * </pre>
     *
     * <code>optional string monitoring_service = 7;</code>
     */
    public Builder setMonitoringServiceBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setMonitoringServiceBytes(value);
      return this;
    }

    /**
     * <pre>
     * The name of the Google Compute Engine
     * [network](/compute/docs/networks-and-firewalls#networks) to which the
     * cluster is connected. If left unspecified, the `default` network
     * will be used.
     * </pre>
     *
     * <code>optional string network = 8;</code>
     */
    public java.lang.String getNetwork() {
      return instance.getNetwork();
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [network](/compute/docs/networks-and-firewalls#networks) to which the
     * cluster is connected. If left unspecified, the `default` network
     * will be used.
     * </pre>
     *
     * <code>optional string network = 8;</code>
     */
    public com.google.protobuf.ByteString
        getNetworkBytes() {
      return instance.getNetworkBytes();
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [network](/compute/docs/networks-and-firewalls#networks) to which the
     * cluster is connected. If left unspecified, the `default` network
     * will be used.
     * </pre>
     *
     * <code>optional string network = 8;</code>
     */
    public Builder setNetwork(
        java.lang.String value) {
      copyOnWrite();
      instance.setNetwork(value);
      return this;
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [network](/compute/docs/networks-and-firewalls#networks) to which the
     * cluster is connected. If left unspecified, the `default` network
     * will be used.
     * </pre>
     *
     * <code>optional string network = 8;</code>
     */
    public Builder clearNetwork() {
      copyOnWrite();
      instance.clearNetwork();
      return this;
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [network](/compute/docs/networks-and-firewalls#networks) to which the
     * cluster is connected. If left unspecified, the `default` network
     * will be used.
     * </pre>
     *
     * <code>optional string network = 8;</code>
     */
    public Builder setNetworkBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNetworkBytes(value);
      return this;
    }

    /**
     * <pre>
     * The IP address range of the container pods in this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `10.96.0.0/14`). Leave blank to have
     * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
     * </pre>
     *
     * <code>optional string cluster_ipv4_cidr = 9;</code>
     */
    public java.lang.String getClusterIpv4Cidr() {
      return instance.getClusterIpv4Cidr();
    }
    /**
     * <pre>
     * The IP address range of the container pods in this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `10.96.0.0/14`). Leave blank to have
     * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
     * </pre>
     *
     * <code>optional string cluster_ipv4_cidr = 9;</code>
     */
    public com.google.protobuf.ByteString
        getClusterIpv4CidrBytes() {
      return instance.getClusterIpv4CidrBytes();
    }
    /**
     * <pre>
     * The IP address range of the container pods in this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `10.96.0.0/14`). Leave blank to have
     * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
     * </pre>
     *
     * <code>optional string cluster_ipv4_cidr = 9;</code>
     */
    public Builder setClusterIpv4Cidr(
        java.lang.String value) {
      copyOnWrite();
      instance.setClusterIpv4Cidr(value);
      return this;
    }
    /**
     * <pre>
     * The IP address range of the container pods in this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `10.96.0.0/14`). Leave blank to have
     * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
     * </pre>
     *
     * <code>optional string cluster_ipv4_cidr = 9;</code>
     */
    public Builder clearClusterIpv4Cidr() {
      copyOnWrite();
      instance.clearClusterIpv4Cidr();
      return this;
    }
    /**
     * <pre>
     * The IP address range of the container pods in this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `10.96.0.0/14`). Leave blank to have
     * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
     * </pre>
     *
     * <code>optional string cluster_ipv4_cidr = 9;</code>
     */
    public Builder setClusterIpv4CidrBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setClusterIpv4CidrBytes(value);
      return this;
    }

    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
     */
    public boolean hasAddonsConfig() {
      return instance.hasAddonsConfig();
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
     */
    public com.google.container.v1.AddonsConfig getAddonsConfig() {
      return instance.getAddonsConfig();
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
     */
    public Builder setAddonsConfig(com.google.container.v1.AddonsConfig value) {
      copyOnWrite();
      instance.setAddonsConfig(value);
      return this;
      }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
     */
    public Builder setAddonsConfig(
        com.google.container.v1.AddonsConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setAddonsConfig(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
     */
    public Builder mergeAddonsConfig(com.google.container.v1.AddonsConfig value) {
      copyOnWrite();
      instance.mergeAddonsConfig(value);
      return this;
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig addons_config = 10;</code>
     */
    public Builder clearAddonsConfig() {  copyOnWrite();
      instance.clearAddonsConfig();
      return this;
    }

    /**
     * <pre>
     * The name of the Google Compute Engine
     * [subnetwork](/compute/docs/subnetworks) to which the
     * cluster is connected.
     * </pre>
     *
     * <code>optional string subnetwork = 11;</code>
     */
    public java.lang.String getSubnetwork() {
      return instance.getSubnetwork();
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [subnetwork](/compute/docs/subnetworks) to which the
     * cluster is connected.
     * </pre>
     *
     * <code>optional string subnetwork = 11;</code>
     */
    public com.google.protobuf.ByteString
        getSubnetworkBytes() {
      return instance.getSubnetworkBytes();
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [subnetwork](/compute/docs/subnetworks) to which the
     * cluster is connected.
     * </pre>
     *
     * <code>optional string subnetwork = 11;</code>
     */
    public Builder setSubnetwork(
        java.lang.String value) {
      copyOnWrite();
      instance.setSubnetwork(value);
      return this;
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [subnetwork](/compute/docs/subnetworks) to which the
     * cluster is connected.
     * </pre>
     *
     * <code>optional string subnetwork = 11;</code>
     */
    public Builder clearSubnetwork() {
      copyOnWrite();
      instance.clearSubnetwork();
      return this;
    }
    /**
     * <pre>
     * The name of the Google Compute Engine
     * [subnetwork](/compute/docs/subnetworks) to which the
     * cluster is connected.
     * </pre>
     *
     * <code>optional string subnetwork = 11;</code>
     */
    public Builder setSubnetworkBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSubnetworkBytes(value);
      return this;
    }

    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public java.util.List<com.google.container.v1.NodePool> getNodePoolsList() {
      return java.util.Collections.unmodifiableList(
          instance.getNodePoolsList());
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public int getNodePoolsCount() {
      return instance.getNodePoolsCount();
    }/**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public com.google.container.v1.NodePool getNodePools(int index) {
      return instance.getNodePools(index);
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder setNodePools(
        int index, com.google.container.v1.NodePool value) {
      copyOnWrite();
      instance.setNodePools(index, value);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder setNodePools(
        int index, com.google.container.v1.NodePool.Builder builderForValue) {
      copyOnWrite();
      instance.setNodePools(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder addNodePools(com.google.container.v1.NodePool value) {
      copyOnWrite();
      instance.addNodePools(value);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder addNodePools(
        int index, com.google.container.v1.NodePool value) {
      copyOnWrite();
      instance.addNodePools(index, value);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder addNodePools(
        com.google.container.v1.NodePool.Builder builderForValue) {
      copyOnWrite();
      instance.addNodePools(builderForValue);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder addNodePools(
        int index, com.google.container.v1.NodePool.Builder builderForValue) {
      copyOnWrite();
      instance.addNodePools(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder addAllNodePools(
        java.lang.Iterable<? extends com.google.container.v1.NodePool> values) {
      copyOnWrite();
      instance.addAllNodePools(values);
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder clearNodePools() {
      copyOnWrite();
      instance.clearNodePools();
      return this;
    }
    /**
     * <pre>
     * The node pools associated with this cluster.
     * This field should not be set if "node_config" or "initial_node_count" are
     * specified.
     * </pre>
     *
     * <code>repeated .google.container.v1.NodePool node_pools = 12;</code>
     */
    public Builder removeNodePools(int index) {
      copyOnWrite();
      instance.removeNodePools(index);
      return this;
    }

    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public java.util.List<String>
        getLocationsList() {
      return java.util.Collections.unmodifiableList(
          instance.getLocationsList());
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public int getLocationsCount() {
      return instance.getLocationsCount();
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public java.lang.String getLocations(int index) {
      return instance.getLocations(index);
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public com.google.protobuf.ByteString
        getLocationsBytes(int index) {
      return instance.getLocationsBytes(index);
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public Builder setLocations(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setLocations(index, value);
      return this;
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public Builder addLocations(
        java.lang.String value) {
      copyOnWrite();
      instance.addLocations(value);
      return this;
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public Builder addAllLocations(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllLocations(values);
      return this;
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public Builder clearLocations() {
      copyOnWrite();
      instance.clearLocations();
      return this;
    }
    /**
     * <pre>
     * The list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located.
     * </pre>
     *
     * <code>repeated string locations = 13;</code>
     */
    public Builder addLocationsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addLocationsBytes(value);
      return this;
    }

    /**
     * <pre>
     * Kubernetes alpha features are enabled on this cluster. This includes alpha
     * API groups (e.g. v1alpha1) and features that may not be production ready in
     * the kubernetes version of the master and nodes.
     * The cluster has no SLA for uptime and master/node upgrades are disabled.
     * Alpha enabled clusters are automatically deleted thirty days after
     * creation.
     * </pre>
     *
     * <code>optional bool enable_kubernetes_alpha = 14;</code>
     */
    public boolean getEnableKubernetesAlpha() {
      return instance.getEnableKubernetesAlpha();
    }
    /**
     * <pre>
     * Kubernetes alpha features are enabled on this cluster. This includes alpha
     * API groups (e.g. v1alpha1) and features that may not be production ready in
     * the kubernetes version of the master and nodes.
     * The cluster has no SLA for uptime and master/node upgrades are disabled.
     * Alpha enabled clusters are automatically deleted thirty days after
     * creation.
     * </pre>
     *
     * <code>optional bool enable_kubernetes_alpha = 14;</code>
     */
    public Builder setEnableKubernetesAlpha(boolean value) {
      copyOnWrite();
      instance.setEnableKubernetesAlpha(value);
      return this;
    }
    /**
     * <pre>
     * Kubernetes alpha features are enabled on this cluster. This includes alpha
     * API groups (e.g. v1alpha1) and features that may not be production ready in
     * the kubernetes version of the master and nodes.
     * The cluster has no SLA for uptime and master/node upgrades are disabled.
     * Alpha enabled clusters are automatically deleted thirty days after
     * creation.
     * </pre>
     *
     * <code>optional bool enable_kubernetes_alpha = 14;</code>
     */
    public Builder clearEnableKubernetesAlpha() {
      copyOnWrite();
      instance.clearEnableKubernetesAlpha();
      return this;
    }

    /**
     * <pre>
     * [Output only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>optional string self_link = 100;</code>
     */
    public java.lang.String getSelfLink() {
      return instance.getSelfLink();
    }
    /**
     * <pre>
     * [Output only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>optional string self_link = 100;</code>
     */
    public com.google.protobuf.ByteString
        getSelfLinkBytes() {
      return instance.getSelfLinkBytes();
    }
    /**
     * <pre>
     * [Output only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>optional string self_link = 100;</code>
     */
    public Builder setSelfLink(
        java.lang.String value) {
      copyOnWrite();
      instance.setSelfLink(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>optional string self_link = 100;</code>
     */
    public Builder clearSelfLink() {
      copyOnWrite();
      instance.clearSelfLink();
      return this;
    }
    /**
     * <pre>
     * [Output only] Server-defined URL for the resource.
     * </pre>
     *
     * <code>optional string self_link = 100;</code>
     */
    public Builder setSelfLinkBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSelfLinkBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The name of the Google Compute Engine
     * [zone](/compute/docs/zones#available) in which the cluster
     * resides.
     * </pre>
     *
     * <code>optional string zone = 101;</code>
     */
    public java.lang.String getZone() {
      return instance.getZone();
    }
    /**
     * <pre>
     * [Output only] The name of the Google Compute Engine
     * [zone](/compute/docs/zones#available) in which the cluster
     * resides.
     * </pre>
     *
     * <code>optional string zone = 101;</code>
     */
    public com.google.protobuf.ByteString
        getZoneBytes() {
      return instance.getZoneBytes();
    }
    /**
     * <pre>
     * [Output only] The name of the Google Compute Engine
     * [zone](/compute/docs/zones#available) in which the cluster
     * resides.
     * </pre>
     *
     * <code>optional string zone = 101;</code>
     */
    public Builder setZone(
        java.lang.String value) {
      copyOnWrite();
      instance.setZone(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The name of the Google Compute Engine
     * [zone](/compute/docs/zones#available) in which the cluster
     * resides.
     * </pre>
     *
     * <code>optional string zone = 101;</code>
     */
    public Builder clearZone() {
      copyOnWrite();
      instance.clearZone();
      return this;
    }
    /**
     * <pre>
     * [Output only] The name of the Google Compute Engine
     * [zone](/compute/docs/zones#available) in which the cluster
     * resides.
     * </pre>
     *
     * <code>optional string zone = 101;</code>
     */
    public Builder setZoneBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setZoneBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The IP address of this cluster's master endpoint.
     * The endpoint can be accessed from the internet at
     * `https://username:password&#64;endpoint/`.
     * See the `masterAuth` property of this resource for username and
     * password information.
     * </pre>
     *
     * <code>optional string endpoint = 102;</code>
     */
    public java.lang.String getEndpoint() {
      return instance.getEndpoint();
    }
    /**
     * <pre>
     * [Output only] The IP address of this cluster's master endpoint.
     * The endpoint can be accessed from the internet at
     * `https://username:password&#64;endpoint/`.
     * See the `masterAuth` property of this resource for username and
     * password information.
     * </pre>
     *
     * <code>optional string endpoint = 102;</code>
     */
    public com.google.protobuf.ByteString
        getEndpointBytes() {
      return instance.getEndpointBytes();
    }
    /**
     * <pre>
     * [Output only] The IP address of this cluster's master endpoint.
     * The endpoint can be accessed from the internet at
     * `https://username:password&#64;endpoint/`.
     * See the `masterAuth` property of this resource for username and
     * password information.
     * </pre>
     *
     * <code>optional string endpoint = 102;</code>
     */
    public Builder setEndpoint(
        java.lang.String value) {
      copyOnWrite();
      instance.setEndpoint(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The IP address of this cluster's master endpoint.
     * The endpoint can be accessed from the internet at
     * `https://username:password&#64;endpoint/`.
     * See the `masterAuth` property of this resource for username and
     * password information.
     * </pre>
     *
     * <code>optional string endpoint = 102;</code>
     */
    public Builder clearEndpoint() {
      copyOnWrite();
      instance.clearEndpoint();
      return this;
    }
    /**
     * <pre>
     * [Output only] The IP address of this cluster's master endpoint.
     * The endpoint can be accessed from the internet at
     * `https://username:password&#64;endpoint/`.
     * See the `masterAuth` property of this resource for username and
     * password information.
     * </pre>
     *
     * <code>optional string endpoint = 102;</code>
     */
    public Builder setEndpointBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEndpointBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The software version of the master endpoint and kubelets used
     * in the cluster when it was first created. The version can be upgraded over
     * time.
     * </pre>
     *
     * <code>optional string initial_cluster_version = 103;</code>
     */
    public java.lang.String getInitialClusterVersion() {
      return instance.getInitialClusterVersion();
    }
    /**
     * <pre>
     * [Output only] The software version of the master endpoint and kubelets used
     * in the cluster when it was first created. The version can be upgraded over
     * time.
     * </pre>
     *
     * <code>optional string initial_cluster_version = 103;</code>
     */
    public com.google.protobuf.ByteString
        getInitialClusterVersionBytes() {
      return instance.getInitialClusterVersionBytes();
    }
    /**
     * <pre>
     * [Output only] The software version of the master endpoint and kubelets used
     * in the cluster when it was first created. The version can be upgraded over
     * time.
     * </pre>
     *
     * <code>optional string initial_cluster_version = 103;</code>
     */
    public Builder setInitialClusterVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setInitialClusterVersion(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The software version of the master endpoint and kubelets used
     * in the cluster when it was first created. The version can be upgraded over
     * time.
     * </pre>
     *
     * <code>optional string initial_cluster_version = 103;</code>
     */
    public Builder clearInitialClusterVersion() {
      copyOnWrite();
      instance.clearInitialClusterVersion();
      return this;
    }
    /**
     * <pre>
     * [Output only] The software version of the master endpoint and kubelets used
     * in the cluster when it was first created. The version can be upgraded over
     * time.
     * </pre>
     *
     * <code>optional string initial_cluster_version = 103;</code>
     */
    public Builder setInitialClusterVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setInitialClusterVersionBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The current software version of the master endpoint.
     * </pre>
     *
     * <code>optional string current_master_version = 104;</code>
     */
    public java.lang.String getCurrentMasterVersion() {
      return instance.getCurrentMasterVersion();
    }
    /**
     * <pre>
     * [Output only] The current software version of the master endpoint.
     * </pre>
     *
     * <code>optional string current_master_version = 104;</code>
     */
    public com.google.protobuf.ByteString
        getCurrentMasterVersionBytes() {
      return instance.getCurrentMasterVersionBytes();
    }
    /**
     * <pre>
     * [Output only] The current software version of the master endpoint.
     * </pre>
     *
     * <code>optional string current_master_version = 104;</code>
     */
    public Builder setCurrentMasterVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setCurrentMasterVersion(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The current software version of the master endpoint.
     * </pre>
     *
     * <code>optional string current_master_version = 104;</code>
     */
    public Builder clearCurrentMasterVersion() {
      copyOnWrite();
      instance.clearCurrentMasterVersion();
      return this;
    }
    /**
     * <pre>
     * [Output only] The current software version of the master endpoint.
     * </pre>
     *
     * <code>optional string current_master_version = 104;</code>
     */
    public Builder setCurrentMasterVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setCurrentMasterVersionBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The current version of the node software components.
     * If they are currently at multiple versions because they're in the process
     * of being upgraded, this reflects the minimum version of all nodes.
     * </pre>
     *
     * <code>optional string current_node_version = 105;</code>
     */
    public java.lang.String getCurrentNodeVersion() {
      return instance.getCurrentNodeVersion();
    }
    /**
     * <pre>
     * [Output only] The current version of the node software components.
     * If they are currently at multiple versions because they're in the process
     * of being upgraded, this reflects the minimum version of all nodes.
     * </pre>
     *
     * <code>optional string current_node_version = 105;</code>
     */
    public com.google.protobuf.ByteString
        getCurrentNodeVersionBytes() {
      return instance.getCurrentNodeVersionBytes();
    }
    /**
     * <pre>
     * [Output only] The current version of the node software components.
     * If they are currently at multiple versions because they're in the process
     * of being upgraded, this reflects the minimum version of all nodes.
     * </pre>
     *
     * <code>optional string current_node_version = 105;</code>
     */
    public Builder setCurrentNodeVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setCurrentNodeVersion(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The current version of the node software components.
     * If they are currently at multiple versions because they're in the process
     * of being upgraded, this reflects the minimum version of all nodes.
     * </pre>
     *
     * <code>optional string current_node_version = 105;</code>
     */
    public Builder clearCurrentNodeVersion() {
      copyOnWrite();
      instance.clearCurrentNodeVersion();
      return this;
    }
    /**
     * <pre>
     * [Output only] The current version of the node software components.
     * If they are currently at multiple versions because they're in the process
     * of being upgraded, this reflects the minimum version of all nodes.
     * </pre>
     *
     * <code>optional string current_node_version = 105;</code>
     */
    public Builder setCurrentNodeVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setCurrentNodeVersionBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The time the cluster was created, in
     * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string create_time = 106;</code>
     */
    public java.lang.String getCreateTime() {
      return instance.getCreateTime();
    }
    /**
     * <pre>
     * [Output only] The time the cluster was created, in
     * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string create_time = 106;</code>
     */
    public com.google.protobuf.ByteString
        getCreateTimeBytes() {
      return instance.getCreateTimeBytes();
    }
    /**
     * <pre>
     * [Output only] The time the cluster was created, in
     * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string create_time = 106;</code>
     */
    public Builder setCreateTime(
        java.lang.String value) {
      copyOnWrite();
      instance.setCreateTime(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The time the cluster was created, in
     * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string create_time = 106;</code>
     */
    public Builder clearCreateTime() {
      copyOnWrite();
      instance.clearCreateTime();
      return this;
    }
    /**
     * <pre>
     * [Output only] The time the cluster was created, in
     * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string create_time = 106;</code>
     */
    public Builder setCreateTimeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setCreateTimeBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The current status of this cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
     */
    public int getStatusValue() {
      return instance.getStatusValue();
    }
    /**
     * <pre>
     * [Output only] The current status of this cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
     */
    public Builder setStatusValue(int value) {
      copyOnWrite();
      instance.setStatusValue(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The current status of this cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
     */
    public com.google.container.v1.Cluster.Status getStatus() {
      return instance.getStatus();
    }
    /**
     * <pre>
     * [Output only] The current status of this cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
     */
    public Builder setStatus(com.google.container.v1.Cluster.Status value) {
      copyOnWrite();
      instance.setStatus(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The current status of this cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.Cluster.Status status = 107;</code>
     */
    public Builder clearStatus() {
      copyOnWrite();
      instance.clearStatus();
      return this;
    }

    /**
     * <pre>
     * [Output only] Additional information about the current status of this
     * cluster, if available.
     * </pre>
     *
     * <code>optional string status_message = 108;</code>
     */
    public java.lang.String getStatusMessage() {
      return instance.getStatusMessage();
    }
    /**
     * <pre>
     * [Output only] Additional information about the current status of this
     * cluster, if available.
     * </pre>
     *
     * <code>optional string status_message = 108;</code>
     */
    public com.google.protobuf.ByteString
        getStatusMessageBytes() {
      return instance.getStatusMessageBytes();
    }
    /**
     * <pre>
     * [Output only] Additional information about the current status of this
     * cluster, if available.
     * </pre>
     *
     * <code>optional string status_message = 108;</code>
     */
    public Builder setStatusMessage(
        java.lang.String value) {
      copyOnWrite();
      instance.setStatusMessage(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] Additional information about the current status of this
     * cluster, if available.
     * </pre>
     *
     * <code>optional string status_message = 108;</code>
     */
    public Builder clearStatusMessage() {
      copyOnWrite();
      instance.clearStatusMessage();
      return this;
    }
    /**
     * <pre>
     * [Output only] Additional information about the current status of this
     * cluster, if available.
     * </pre>
     *
     * <code>optional string status_message = 108;</code>
     */
    public Builder setStatusMessageBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setStatusMessageBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The size of the address space on each node for hosting
     * containers. This is provisioned from within the `container_ipv4_cidr`
     * range.
     * </pre>
     *
     * <code>optional int32 node_ipv4_cidr_size = 109;</code>
     */
    public int getNodeIpv4CidrSize() {
      return instance.getNodeIpv4CidrSize();
    }
    /**
     * <pre>
     * [Output only] The size of the address space on each node for hosting
     * containers. This is provisioned from within the `container_ipv4_cidr`
     * range.
     * </pre>
     *
     * <code>optional int32 node_ipv4_cidr_size = 109;</code>
     */
    public Builder setNodeIpv4CidrSize(int value) {
      copyOnWrite();
      instance.setNodeIpv4CidrSize(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The size of the address space on each node for hosting
     * containers. This is provisioned from within the `container_ipv4_cidr`
     * range.
     * </pre>
     *
     * <code>optional int32 node_ipv4_cidr_size = 109;</code>
     */
    public Builder clearNodeIpv4CidrSize() {
      copyOnWrite();
      instance.clearNodeIpv4CidrSize();
      return this;
    }

    /**
     * <pre>
     * [Output only] The IP address range of the Kubernetes services in
     * this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `1.2.3.4/29`). Service addresses are
     * typically put in the last `/16` from the container CIDR.
     * </pre>
     *
     * <code>optional string services_ipv4_cidr = 110;</code>
     */
    public java.lang.String getServicesIpv4Cidr() {
      return instance.getServicesIpv4Cidr();
    }
    /**
     * <pre>
     * [Output only] The IP address range of the Kubernetes services in
     * this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `1.2.3.4/29`). Service addresses are
     * typically put in the last `/16` from the container CIDR.
     * </pre>
     *
     * <code>optional string services_ipv4_cidr = 110;</code>
     */
    public com.google.protobuf.ByteString
        getServicesIpv4CidrBytes() {
      return instance.getServicesIpv4CidrBytes();
    }
    /**
     * <pre>
     * [Output only] The IP address range of the Kubernetes services in
     * this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `1.2.3.4/29`). Service addresses are
     * typically put in the last `/16` from the container CIDR.
     * </pre>
     *
     * <code>optional string services_ipv4_cidr = 110;</code>
     */
    public Builder setServicesIpv4Cidr(
        java.lang.String value) {
      copyOnWrite();
      instance.setServicesIpv4Cidr(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The IP address range of the Kubernetes services in
     * this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `1.2.3.4/29`). Service addresses are
     * typically put in the last `/16` from the container CIDR.
     * </pre>
     *
     * <code>optional string services_ipv4_cidr = 110;</code>
     */
    public Builder clearServicesIpv4Cidr() {
      copyOnWrite();
      instance.clearServicesIpv4Cidr();
      return this;
    }
    /**
     * <pre>
     * [Output only] The IP address range of the Kubernetes services in
     * this cluster, in
     * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
     * notation (e.g. `1.2.3.4/29`). Service addresses are
     * typically put in the last `/16` from the container CIDR.
     * </pre>
     *
     * <code>optional string services_ipv4_cidr = 110;</code>
     */
    public Builder setServicesIpv4CidrBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setServicesIpv4CidrBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public java.util.List<String>
        getInstanceGroupUrlsList() {
      return java.util.Collections.unmodifiableList(
          instance.getInstanceGroupUrlsList());
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public int getInstanceGroupUrlsCount() {
      return instance.getInstanceGroupUrlsCount();
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public java.lang.String getInstanceGroupUrls(int index) {
      return instance.getInstanceGroupUrls(index);
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public com.google.protobuf.ByteString
        getInstanceGroupUrlsBytes(int index) {
      return instance.getInstanceGroupUrlsBytes(index);
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public Builder setInstanceGroupUrls(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setInstanceGroupUrls(index, value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public Builder addInstanceGroupUrls(
        java.lang.String value) {
      copyOnWrite();
      instance.addInstanceGroupUrls(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public Builder addAllInstanceGroupUrls(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllInstanceGroupUrls(values);
      return this;
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public Builder clearInstanceGroupUrls() {
      copyOnWrite();
      instance.clearInstanceGroupUrls();
      return this;
    }
    /**
     * <pre>
     * [Output only] The resource URLs of [instance
     * groups](/compute/docs/instance-groups/) associated with this
     * cluster.
     * </pre>
     *
     * <code>repeated string instance_group_urls = 111;</code>
     */
    public Builder addInstanceGroupUrlsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addInstanceGroupUrlsBytes(value);
      return this;
    }

    /**
     * <pre>
     * [Output only] The number of nodes currently in the cluster.
     * </pre>
     *
     * <code>optional int32 current_node_count = 112;</code>
     */
    public int getCurrentNodeCount() {
      return instance.getCurrentNodeCount();
    }
    /**
     * <pre>
     * [Output only] The number of nodes currently in the cluster.
     * </pre>
     *
     * <code>optional int32 current_node_count = 112;</code>
     */
    public Builder setCurrentNodeCount(int value) {
      copyOnWrite();
      instance.setCurrentNodeCount(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The number of nodes currently in the cluster.
     * </pre>
     *
     * <code>optional int32 current_node_count = 112;</code>
     */
    public Builder clearCurrentNodeCount() {
      copyOnWrite();
      instance.clearCurrentNodeCount();
      return this;
    }

    /**
     * <pre>
     * [Output only] The time the cluster will be automatically
     * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string expire_time = 113;</code>
     */
    public java.lang.String getExpireTime() {
      return instance.getExpireTime();
    }
    /**
     * <pre>
     * [Output only] The time the cluster will be automatically
     * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string expire_time = 113;</code>
     */
    public com.google.protobuf.ByteString
        getExpireTimeBytes() {
      return instance.getExpireTimeBytes();
    }
    /**
     * <pre>
     * [Output only] The time the cluster will be automatically
     * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string expire_time = 113;</code>
     */
    public Builder setExpireTime(
        java.lang.String value) {
      copyOnWrite();
      instance.setExpireTime(value);
      return this;
    }
    /**
     * <pre>
     * [Output only] The time the cluster will be automatically
     * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string expire_time = 113;</code>
     */
    public Builder clearExpireTime() {
      copyOnWrite();
      instance.clearExpireTime();
      return this;
    }
    /**
     * <pre>
     * [Output only] The time the cluster will be automatically
     * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
     * </pre>
     *
     * <code>optional string expire_time = 113;</code>
     */
    public Builder setExpireTimeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setExpireTimeBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.container.v1.Cluster)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.container.v1.Cluster();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        nodePools_.makeImmutable();
        locations_.makeImmutable();
        instanceGroupUrls_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        com.google.container.v1.Cluster other = (com.google.container.v1.Cluster) arg1;
        name_ = visitor.visitString(!name_.isEmpty(), name_,
            !other.name_.isEmpty(), other.name_);
        description_ = visitor.visitString(!description_.isEmpty(), description_,
            !other.description_.isEmpty(), other.description_);
        initialNodeCount_ = visitor.visitInt(initialNodeCount_ != 0, initialNodeCount_,
            other.initialNodeCount_ != 0, other.initialNodeCount_);
        nodeConfig_ = visitor.visitMessage(nodeConfig_, other.nodeConfig_);
        masterAuth_ = visitor.visitMessage(masterAuth_, other.masterAuth_);
        loggingService_ = visitor.visitString(!loggingService_.isEmpty(), loggingService_,
            !other.loggingService_.isEmpty(), other.loggingService_);
        monitoringService_ = visitor.visitString(!monitoringService_.isEmpty(), monitoringService_,
            !other.monitoringService_.isEmpty(), other.monitoringService_);
        network_ = visitor.visitString(!network_.isEmpty(), network_,
            !other.network_.isEmpty(), other.network_);
        clusterIpv4Cidr_ = visitor.visitString(!clusterIpv4Cidr_.isEmpty(), clusterIpv4Cidr_,
            !other.clusterIpv4Cidr_.isEmpty(), other.clusterIpv4Cidr_);
        addonsConfig_ = visitor.visitMessage(addonsConfig_, other.addonsConfig_);
        subnetwork_ = visitor.visitString(!subnetwork_.isEmpty(), subnetwork_,
            !other.subnetwork_.isEmpty(), other.subnetwork_);
        nodePools_= visitor.visitList(nodePools_, other.nodePools_);
        locations_= visitor.visitList(locations_, other.locations_);
        enableKubernetesAlpha_ = visitor.visitBoolean(enableKubernetesAlpha_ != false, enableKubernetesAlpha_,
            other.enableKubernetesAlpha_ != false, other.enableKubernetesAlpha_);
        selfLink_ = visitor.visitString(!selfLink_.isEmpty(), selfLink_,
            !other.selfLink_.isEmpty(), other.selfLink_);
        zone_ = visitor.visitString(!zone_.isEmpty(), zone_,
            !other.zone_.isEmpty(), other.zone_);
        endpoint_ = visitor.visitString(!endpoint_.isEmpty(), endpoint_,
            !other.endpoint_.isEmpty(), other.endpoint_);
        initialClusterVersion_ = visitor.visitString(!initialClusterVersion_.isEmpty(), initialClusterVersion_,
            !other.initialClusterVersion_.isEmpty(), other.initialClusterVersion_);
        currentMasterVersion_ = visitor.visitString(!currentMasterVersion_.isEmpty(), currentMasterVersion_,
            !other.currentMasterVersion_.isEmpty(), other.currentMasterVersion_);
        currentNodeVersion_ = visitor.visitString(!currentNodeVersion_.isEmpty(), currentNodeVersion_,
            !other.currentNodeVersion_.isEmpty(), other.currentNodeVersion_);
        createTime_ = visitor.visitString(!createTime_.isEmpty(), createTime_,
            !other.createTime_.isEmpty(), other.createTime_);
        status_ = visitor.visitInt(status_ != 0, status_,    other.status_ != 0, other.status_);
        statusMessage_ = visitor.visitString(!statusMessage_.isEmpty(), statusMessage_,
            !other.statusMessage_.isEmpty(), other.statusMessage_);
        nodeIpv4CidrSize_ = visitor.visitInt(nodeIpv4CidrSize_ != 0, nodeIpv4CidrSize_,
            other.nodeIpv4CidrSize_ != 0, other.nodeIpv4CidrSize_);
        servicesIpv4Cidr_ = visitor.visitString(!servicesIpv4Cidr_.isEmpty(), servicesIpv4Cidr_,
            !other.servicesIpv4Cidr_.isEmpty(), other.servicesIpv4Cidr_);
        instanceGroupUrls_= visitor.visitList(instanceGroupUrls_, other.instanceGroupUrls_);
        currentNodeCount_ = visitor.visitInt(currentNodeCount_ != 0, currentNodeCount_,
            other.currentNodeCount_ != 0, other.currentNodeCount_);
        expireTime_ = visitor.visitString(!expireTime_.isEmpty(), expireTime_,
            !other.expireTime_.isEmpty(), other.expireTime_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 10: {
                String s = input.readStringRequireUtf8();

                name_ = s;
                break;
              }
              case 18: {
                String s = input.readStringRequireUtf8();

                description_ = s;
                break;
              }
              case 24: {

                initialNodeCount_ = input.readInt32();
                break;
              }
              case 34: {
                com.google.container.v1.NodeConfig.Builder subBuilder = null;
                if (nodeConfig_ != null) {
                  subBuilder = nodeConfig_.toBuilder();
                }
                nodeConfig_ = input.readMessage(com.google.container.v1.NodeConfig.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(nodeConfig_);
                  nodeConfig_ = subBuilder.buildPartial();
                }

                break;
              }
              case 42: {
                com.google.container.v1.MasterAuth.Builder subBuilder = null;
                if (masterAuth_ != null) {
                  subBuilder = masterAuth_.toBuilder();
                }
                masterAuth_ = input.readMessage(com.google.container.v1.MasterAuth.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(masterAuth_);
                  masterAuth_ = subBuilder.buildPartial();
                }

                break;
              }
              case 50: {
                String s = input.readStringRequireUtf8();

                loggingService_ = s;
                break;
              }
              case 58: {
                String s = input.readStringRequireUtf8();

                monitoringService_ = s;
                break;
              }
              case 66: {
                String s = input.readStringRequireUtf8();

                network_ = s;
                break;
              }
              case 74: {
                String s = input.readStringRequireUtf8();

                clusterIpv4Cidr_ = s;
                break;
              }
              case 82: {
                com.google.container.v1.AddonsConfig.Builder subBuilder = null;
                if (addonsConfig_ != null) {
                  subBuilder = addonsConfig_.toBuilder();
                }
                addonsConfig_ = input.readMessage(com.google.container.v1.AddonsConfig.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(addonsConfig_);
                  addonsConfig_ = subBuilder.buildPartial();
                }

                break;
              }
              case 90: {
                String s = input.readStringRequireUtf8();

                subnetwork_ = s;
                break;
              }
              case 98: {
                if (!nodePools_.isModifiable()) {
                  nodePools_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(nodePools_);
                }
                nodePools_.add(
                    input.readMessage(com.google.container.v1.NodePool.parser(), extensionRegistry));
                break;
              }
              case 106: {
                String s = input.readStringRequireUtf8();
                if (!locations_.isModifiable()) {
                  locations_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(locations_);
                }
                locations_.add(s);
                break;
              }
              case 112: {

                enableKubernetesAlpha_ = input.readBool();
                break;
              }
              case 802: {
                String s = input.readStringRequireUtf8();

                selfLink_ = s;
                break;
              }
              case 810: {
                String s = input.readStringRequireUtf8();

                zone_ = s;
                break;
              }
              case 818: {
                String s = input.readStringRequireUtf8();

                endpoint_ = s;
                break;
              }
              case 826: {
                String s = input.readStringRequireUtf8();

                initialClusterVersion_ = s;
                break;
              }
              case 834: {
                String s = input.readStringRequireUtf8();

                currentMasterVersion_ = s;
                break;
              }
              case 842: {
                String s = input.readStringRequireUtf8();

                currentNodeVersion_ = s;
                break;
              }
              case 850: {
                String s = input.readStringRequireUtf8();

                createTime_ = s;
                break;
              }
              case 856: {
                int rawValue = input.readEnum();

                status_ = rawValue;
                break;
              }
              case 866: {
                String s = input.readStringRequireUtf8();

                statusMessage_ = s;
                break;
              }
              case 872: {

                nodeIpv4CidrSize_ = input.readInt32();
                break;
              }
              case 882: {
                String s = input.readStringRequireUtf8();

                servicesIpv4Cidr_ = s;
                break;
              }
              case 890: {
                String s = input.readStringRequireUtf8();
                if (!instanceGroupUrls_.isModifiable()) {
                  instanceGroupUrls_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(instanceGroupUrls_);
                }
                instanceGroupUrls_.add(s);
                break;
              }
              case 896: {

                currentNodeCount_ = input.readInt32();
                break;
              }
              case 906: {
                String s = input.readStringRequireUtf8();

                expireTime_ = s;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (com.google.container.v1.Cluster.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.container.v1.Cluster)
  private static final com.google.container.v1.Cluster DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new Cluster();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static com.google.container.v1.Cluster getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<Cluster> PARSER;

  public static com.google.protobuf.Parser<Cluster> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

