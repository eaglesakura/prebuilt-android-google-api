// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/container/v1/cluster_service.proto

package com.google.container.v1;

/**
 * <pre>
 * ClusterUpdate describes an update to the cluster. Exactly one update can
 * be applied to a cluster with each request, so at most one field can be
 * provided.
 * </pre>
 *
 * Protobuf type {@code google.container.v1.ClusterUpdate}
 */
public  final class ClusterUpdate extends
    com.google.protobuf.GeneratedMessageLite<
        ClusterUpdate, ClusterUpdate.Builder> implements
    // @@protoc_insertion_point(message_implements:google.container.v1.ClusterUpdate)
    ClusterUpdateOrBuilder {
  private ClusterUpdate() {
    desiredNodeVersion_ = "";
    desiredMonitoringService_ = "";
    desiredNodePoolId_ = "";
    desiredImageType_ = "";
    desiredLocations_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    desiredMasterVersion_ = "";
  }
  private int bitField0_;
  public static final int DESIRED_NODE_VERSION_FIELD_NUMBER = 4;
  private java.lang.String desiredNodeVersion_;
  /**
   * <pre>
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   * </pre>
   *
   * <code>optional string desired_node_version = 4;</code>
   */
  public java.lang.String getDesiredNodeVersion() {
    return desiredNodeVersion_;
  }
  /**
   * <pre>
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   * </pre>
   *
   * <code>optional string desired_node_version = 4;</code>
   */
  public com.google.protobuf.ByteString
      getDesiredNodeVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(desiredNodeVersion_);
  }
  /**
   * <pre>
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   * </pre>
   *
   * <code>optional string desired_node_version = 4;</code>
   */
  private void setDesiredNodeVersion(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    desiredNodeVersion_ = value;
  }
  /**
   * <pre>
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   * </pre>
   *
   * <code>optional string desired_node_version = 4;</code>
   */
  private void clearDesiredNodeVersion() {
    
    desiredNodeVersion_ = getDefaultInstance().getDesiredNodeVersion();
  }
  /**
   * <pre>
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   * </pre>
   *
   * <code>optional string desired_node_version = 4;</code>
   */
  private void setDesiredNodeVersionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    desiredNodeVersion_ = value.toStringUtf8();
  }

  public static final int DESIRED_MONITORING_SERVICE_FIELD_NUMBER = 5;
  private java.lang.String desiredMonitoringService_;
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   * </pre>
   *
   * <code>optional string desired_monitoring_service = 5;</code>
   */
  public java.lang.String getDesiredMonitoringService() {
    return desiredMonitoringService_;
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   * </pre>
   *
   * <code>optional string desired_monitoring_service = 5;</code>
   */
  public com.google.protobuf.ByteString
      getDesiredMonitoringServiceBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(desiredMonitoringService_);
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   * </pre>
   *
   * <code>optional string desired_monitoring_service = 5;</code>
   */
  private void setDesiredMonitoringService(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    desiredMonitoringService_ = value;
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   * </pre>
   *
   * <code>optional string desired_monitoring_service = 5;</code>
   */
  private void clearDesiredMonitoringService() {
    
    desiredMonitoringService_ = getDefaultInstance().getDesiredMonitoringService();
  }
  /**
   * <pre>
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   * </pre>
   *
   * <code>optional string desired_monitoring_service = 5;</code>
   */
  private void setDesiredMonitoringServiceBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    desiredMonitoringService_ = value.toStringUtf8();
  }

  public static final int DESIRED_ADDONS_CONFIG_FIELD_NUMBER = 6;
  private com.google.container.v1.AddonsConfig desiredAddonsConfig_;
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
   */
  public boolean hasDesiredAddonsConfig() {
    return desiredAddonsConfig_ != null;
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
   */
  public com.google.container.v1.AddonsConfig getDesiredAddonsConfig() {
    return desiredAddonsConfig_ == null ? com.google.container.v1.AddonsConfig.getDefaultInstance() : desiredAddonsConfig_;
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
   */
  private void setDesiredAddonsConfig(com.google.container.v1.AddonsConfig value) {
    if (value == null) {
      throw new NullPointerException();
    }
    desiredAddonsConfig_ = value;
    
    }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
   */
  private void setDesiredAddonsConfig(
      com.google.container.v1.AddonsConfig.Builder builderForValue) {
    desiredAddonsConfig_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
   */
  private void mergeDesiredAddonsConfig(com.google.container.v1.AddonsConfig value) {
    if (desiredAddonsConfig_ != null &&
        desiredAddonsConfig_ != com.google.container.v1.AddonsConfig.getDefaultInstance()) {
      desiredAddonsConfig_ =
        com.google.container.v1.AddonsConfig.newBuilder(desiredAddonsConfig_).mergeFrom(value).buildPartial();
    } else {
      desiredAddonsConfig_ = value;
    }
    
  }
  /**
   * <pre>
   * Configurations for the various addons available to run in the cluster.
   * </pre>
   *
   * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
   */
  private void clearDesiredAddonsConfig() {  desiredAddonsConfig_ = null;
    
  }

  public static final int DESIRED_NODE_POOL_ID_FIELD_NUMBER = 7;
  private java.lang.String desiredNodePoolId_;
  /**
   * <pre>
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   * </pre>
   *
   * <code>optional string desired_node_pool_id = 7;</code>
   */
  public java.lang.String getDesiredNodePoolId() {
    return desiredNodePoolId_;
  }
  /**
   * <pre>
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   * </pre>
   *
   * <code>optional string desired_node_pool_id = 7;</code>
   */
  public com.google.protobuf.ByteString
      getDesiredNodePoolIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(desiredNodePoolId_);
  }
  /**
   * <pre>
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   * </pre>
   *
   * <code>optional string desired_node_pool_id = 7;</code>
   */
  private void setDesiredNodePoolId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    desiredNodePoolId_ = value;
  }
  /**
   * <pre>
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   * </pre>
   *
   * <code>optional string desired_node_pool_id = 7;</code>
   */
  private void clearDesiredNodePoolId() {
    
    desiredNodePoolId_ = getDefaultInstance().getDesiredNodePoolId();
  }
  /**
   * <pre>
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   * </pre>
   *
   * <code>optional string desired_node_pool_id = 7;</code>
   */
  private void setDesiredNodePoolIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    desiredNodePoolId_ = value.toStringUtf8();
  }

  public static final int DESIRED_IMAGE_TYPE_FIELD_NUMBER = 8;
  private java.lang.String desiredImageType_;
  /**
   * <pre>
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   * </pre>
   *
   * <code>optional string desired_image_type = 8;</code>
   */
  public java.lang.String getDesiredImageType() {
    return desiredImageType_;
  }
  /**
   * <pre>
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   * </pre>
   *
   * <code>optional string desired_image_type = 8;</code>
   */
  public com.google.protobuf.ByteString
      getDesiredImageTypeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(desiredImageType_);
  }
  /**
   * <pre>
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   * </pre>
   *
   * <code>optional string desired_image_type = 8;</code>
   */
  private void setDesiredImageType(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    desiredImageType_ = value;
  }
  /**
   * <pre>
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   * </pre>
   *
   * <code>optional string desired_image_type = 8;</code>
   */
  private void clearDesiredImageType() {
    
    desiredImageType_ = getDefaultInstance().getDesiredImageType();
  }
  /**
   * <pre>
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   * </pre>
   *
   * <code>optional string desired_image_type = 8;</code>
   */
  private void setDesiredImageTypeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    desiredImageType_ = value.toStringUtf8();
  }

  public static final int DESIRED_NODE_POOL_AUTOSCALING_FIELD_NUMBER = 9;
  private com.google.container.v1.NodePoolAutoscaling desiredNodePoolAutoscaling_;
  /**
   * <pre>
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   * </pre>
   *
   * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
   */
  public boolean hasDesiredNodePoolAutoscaling() {
    return desiredNodePoolAutoscaling_ != null;
  }
  /**
   * <pre>
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   * </pre>
   *
   * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
   */
  public com.google.container.v1.NodePoolAutoscaling getDesiredNodePoolAutoscaling() {
    return desiredNodePoolAutoscaling_ == null ? com.google.container.v1.NodePoolAutoscaling.getDefaultInstance() : desiredNodePoolAutoscaling_;
  }
  /**
   * <pre>
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   * </pre>
   *
   * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
   */
  private void setDesiredNodePoolAutoscaling(com.google.container.v1.NodePoolAutoscaling value) {
    if (value == null) {
      throw new NullPointerException();
    }
    desiredNodePoolAutoscaling_ = value;
    
    }
  /**
   * <pre>
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   * </pre>
   *
   * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
   */
  private void setDesiredNodePoolAutoscaling(
      com.google.container.v1.NodePoolAutoscaling.Builder builderForValue) {
    desiredNodePoolAutoscaling_ = builderForValue.build();
    
  }
  /**
   * <pre>
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   * </pre>
   *
   * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
   */
  private void mergeDesiredNodePoolAutoscaling(com.google.container.v1.NodePoolAutoscaling value) {
    if (desiredNodePoolAutoscaling_ != null &&
        desiredNodePoolAutoscaling_ != com.google.container.v1.NodePoolAutoscaling.getDefaultInstance()) {
      desiredNodePoolAutoscaling_ =
        com.google.container.v1.NodePoolAutoscaling.newBuilder(desiredNodePoolAutoscaling_).mergeFrom(value).buildPartial();
    } else {
      desiredNodePoolAutoscaling_ = value;
    }
    
  }
  /**
   * <pre>
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   * </pre>
   *
   * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
   */
  private void clearDesiredNodePoolAutoscaling() {  desiredNodePoolAutoscaling_ = null;
    
  }

  public static final int DESIRED_LOCATIONS_FIELD_NUMBER = 10;
  private com.google.protobuf.Internal.ProtobufList<String> desiredLocations_;
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  public java.util.List<String> getDesiredLocationsList() {
    return desiredLocations_;
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  public int getDesiredLocationsCount() {
    return desiredLocations_.size();
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  public java.lang.String getDesiredLocations(int index) {
    return desiredLocations_.get(index);
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  public com.google.protobuf.ByteString
      getDesiredLocationsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        desiredLocations_.get(index));
  }
  private void ensureDesiredLocationsIsMutable() {
    if (!desiredLocations_.isModifiable()) {
      desiredLocations_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(desiredLocations_);
     }
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  private void setDesiredLocations(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureDesiredLocationsIsMutable();
    desiredLocations_.set(index, value);
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  private void addDesiredLocations(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureDesiredLocationsIsMutable();
    desiredLocations_.add(value);
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  private void addAllDesiredLocations(
      java.lang.Iterable<java.lang.String> values) {
    ensureDesiredLocationsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, desiredLocations_);
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  private void clearDesiredLocations() {
    desiredLocations_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   * This list must always include the cluster's primary zone.
   * </pre>
   *
   * <code>repeated string desired_locations = 10;</code>
   */
  private void addDesiredLocationsBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureDesiredLocationsIsMutable();
    desiredLocations_.add(value.toStringUtf8());
  }

  public static final int DESIRED_MASTER_VERSION_FIELD_NUMBER = 100;
  private java.lang.String desiredMasterVersion_;
  /**
   * <pre>
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   * </pre>
   *
   * <code>optional string desired_master_version = 100;</code>
   */
  public java.lang.String getDesiredMasterVersion() {
    return desiredMasterVersion_;
  }
  /**
   * <pre>
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   * </pre>
   *
   * <code>optional string desired_master_version = 100;</code>
   */
  public com.google.protobuf.ByteString
      getDesiredMasterVersionBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(desiredMasterVersion_);
  }
  /**
   * <pre>
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   * </pre>
   *
   * <code>optional string desired_master_version = 100;</code>
   */
  private void setDesiredMasterVersion(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    desiredMasterVersion_ = value;
  }
  /**
   * <pre>
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   * </pre>
   *
   * <code>optional string desired_master_version = 100;</code>
   */
  private void clearDesiredMasterVersion() {
    
    desiredMasterVersion_ = getDefaultInstance().getDesiredMasterVersion();
  }
  /**
   * <pre>
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   * </pre>
   *
   * <code>optional string desired_master_version = 100;</code>
   */
  private void setDesiredMasterVersionBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    desiredMasterVersion_ = value.toStringUtf8();
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (!desiredNodeVersion_.isEmpty()) {
      output.writeString(4, getDesiredNodeVersion());
    }
    if (!desiredMonitoringService_.isEmpty()) {
      output.writeString(5, getDesiredMonitoringService());
    }
    if (desiredAddonsConfig_ != null) {
      output.writeMessage(6, getDesiredAddonsConfig());
    }
    if (!desiredNodePoolId_.isEmpty()) {
      output.writeString(7, getDesiredNodePoolId());
    }
    if (!desiredImageType_.isEmpty()) {
      output.writeString(8, getDesiredImageType());
    }
    if (desiredNodePoolAutoscaling_ != null) {
      output.writeMessage(9, getDesiredNodePoolAutoscaling());
    }
    for (int i = 0; i < desiredLocations_.size(); i++) {
      output.writeString(10, desiredLocations_.get(i));
    }
    if (!desiredMasterVersion_.isEmpty()) {
      output.writeString(100, getDesiredMasterVersion());
    }
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (!desiredNodeVersion_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(4, getDesiredNodeVersion());
    }
    if (!desiredMonitoringService_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(5, getDesiredMonitoringService());
    }
    if (desiredAddonsConfig_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getDesiredAddonsConfig());
    }
    if (!desiredNodePoolId_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(7, getDesiredNodePoolId());
    }
    if (!desiredImageType_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(8, getDesiredImageType());
    }
    if (desiredNodePoolAutoscaling_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getDesiredNodePoolAutoscaling());
    }
    {
      int dataSize = 0;
      for (int i = 0; i < desiredLocations_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(desiredLocations_.get(i));
      }
      size += dataSize;
      size += 1 * getDesiredLocationsList().size();
    }
    if (!desiredMasterVersion_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(100, getDesiredMasterVersion());
    }
    memoizedSerializedSize = size;
    return size;
  }

  public static com.google.container.v1.ClusterUpdate parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.container.v1.ClusterUpdate parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.ClusterUpdate parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.container.v1.ClusterUpdate parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.container.v1.ClusterUpdate prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * ClusterUpdate describes an update to the cluster. Exactly one update can
   * be applied to a cluster with each request, so at most one field can be
   * provided.
   * </pre>
   *
   * Protobuf type {@code google.container.v1.ClusterUpdate}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.container.v1.ClusterUpdate, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.container.v1.ClusterUpdate)
      com.google.container.v1.ClusterUpdateOrBuilder {
    // Construct using com.google.container.v1.ClusterUpdate.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The Kubernetes version to change the nodes to (typically an
     * upgrade). Use `-` to upgrade to the latest version supported by
     * the server.
     * </pre>
     *
     * <code>optional string desired_node_version = 4;</code>
     */
    public java.lang.String getDesiredNodeVersion() {
      return instance.getDesiredNodeVersion();
    }
    /**
     * <pre>
     * The Kubernetes version to change the nodes to (typically an
     * upgrade). Use `-` to upgrade to the latest version supported by
     * the server.
     * </pre>
     *
     * <code>optional string desired_node_version = 4;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredNodeVersionBytes() {
      return instance.getDesiredNodeVersionBytes();
    }
    /**
     * <pre>
     * The Kubernetes version to change the nodes to (typically an
     * upgrade). Use `-` to upgrade to the latest version supported by
     * the server.
     * </pre>
     *
     * <code>optional string desired_node_version = 4;</code>
     */
    public Builder setDesiredNodeVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setDesiredNodeVersion(value);
      return this;
    }
    /**
     * <pre>
     * The Kubernetes version to change the nodes to (typically an
     * upgrade). Use `-` to upgrade to the latest version supported by
     * the server.
     * </pre>
     *
     * <code>optional string desired_node_version = 4;</code>
     */
    public Builder clearDesiredNodeVersion() {
      copyOnWrite();
      instance.clearDesiredNodeVersion();
      return this;
    }
    /**
     * <pre>
     * The Kubernetes version to change the nodes to (typically an
     * upgrade). Use `-` to upgrade to the latest version supported by
     * the server.
     * </pre>
     *
     * <code>optional string desired_node_version = 4;</code>
     */
    public Builder setDesiredNodeVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDesiredNodeVersionBytes(value);
      return this;
    }

    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
     * * "none" - no metrics will be exported from the cluster
     * </pre>
     *
     * <code>optional string desired_monitoring_service = 5;</code>
     */
    public java.lang.String getDesiredMonitoringService() {
      return instance.getDesiredMonitoringService();
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
     * * "none" - no metrics will be exported from the cluster
     * </pre>
     *
     * <code>optional string desired_monitoring_service = 5;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredMonitoringServiceBytes() {
      return instance.getDesiredMonitoringServiceBytes();
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
     * * "none" - no metrics will be exported from the cluster
     * </pre>
     *
     * <code>optional string desired_monitoring_service = 5;</code>
     */
    public Builder setDesiredMonitoringService(
        java.lang.String value) {
      copyOnWrite();
      instance.setDesiredMonitoringService(value);
      return this;
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
     * * "none" - no metrics will be exported from the cluster
     * </pre>
     *
     * <code>optional string desired_monitoring_service = 5;</code>
     */
    public Builder clearDesiredMonitoringService() {
      copyOnWrite();
      instance.clearDesiredMonitoringService();
      return this;
    }
    /**
     * <pre>
     * The monitoring service the cluster should use to write metrics.
     * Currently available options:
     * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
     * * "none" - no metrics will be exported from the cluster
     * </pre>
     *
     * <code>optional string desired_monitoring_service = 5;</code>
     */
    public Builder setDesiredMonitoringServiceBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDesiredMonitoringServiceBytes(value);
      return this;
    }

    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
     */
    public boolean hasDesiredAddonsConfig() {
      return instance.hasDesiredAddonsConfig();
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
     */
    public com.google.container.v1.AddonsConfig getDesiredAddonsConfig() {
      return instance.getDesiredAddonsConfig();
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
     */
    public Builder setDesiredAddonsConfig(com.google.container.v1.AddonsConfig value) {
      copyOnWrite();
      instance.setDesiredAddonsConfig(value);
      return this;
      }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
     */
    public Builder setDesiredAddonsConfig(
        com.google.container.v1.AddonsConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setDesiredAddonsConfig(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
     */
    public Builder mergeDesiredAddonsConfig(com.google.container.v1.AddonsConfig value) {
      copyOnWrite();
      instance.mergeDesiredAddonsConfig(value);
      return this;
    }
    /**
     * <pre>
     * Configurations for the various addons available to run in the cluster.
     * </pre>
     *
     * <code>optional .google.container.v1.AddonsConfig desired_addons_config = 6;</code>
     */
    public Builder clearDesiredAddonsConfig() {  copyOnWrite();
      instance.clearDesiredAddonsConfig();
      return this;
    }

    /**
     * <pre>
     * The node pool to be upgraded. This field is mandatory if
     * "desired_node_version", "desired_image_family" or
     * "desired_node_pool_autoscaling" is specified and there is more than one
     * node pool on the cluster.
     * </pre>
     *
     * <code>optional string desired_node_pool_id = 7;</code>
     */
    public java.lang.String getDesiredNodePoolId() {
      return instance.getDesiredNodePoolId();
    }
    /**
     * <pre>
     * The node pool to be upgraded. This field is mandatory if
     * "desired_node_version", "desired_image_family" or
     * "desired_node_pool_autoscaling" is specified and there is more than one
     * node pool on the cluster.
     * </pre>
     *
     * <code>optional string desired_node_pool_id = 7;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredNodePoolIdBytes() {
      return instance.getDesiredNodePoolIdBytes();
    }
    /**
     * <pre>
     * The node pool to be upgraded. This field is mandatory if
     * "desired_node_version", "desired_image_family" or
     * "desired_node_pool_autoscaling" is specified and there is more than one
     * node pool on the cluster.
     * </pre>
     *
     * <code>optional string desired_node_pool_id = 7;</code>
     */
    public Builder setDesiredNodePoolId(
        java.lang.String value) {
      copyOnWrite();
      instance.setDesiredNodePoolId(value);
      return this;
    }
    /**
     * <pre>
     * The node pool to be upgraded. This field is mandatory if
     * "desired_node_version", "desired_image_family" or
     * "desired_node_pool_autoscaling" is specified and there is more than one
     * node pool on the cluster.
     * </pre>
     *
     * <code>optional string desired_node_pool_id = 7;</code>
     */
    public Builder clearDesiredNodePoolId() {
      copyOnWrite();
      instance.clearDesiredNodePoolId();
      return this;
    }
    /**
     * <pre>
     * The node pool to be upgraded. This field is mandatory if
     * "desired_node_version", "desired_image_family" or
     * "desired_node_pool_autoscaling" is specified and there is more than one
     * node pool on the cluster.
     * </pre>
     *
     * <code>optional string desired_node_pool_id = 7;</code>
     */
    public Builder setDesiredNodePoolIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDesiredNodePoolIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * The desired image type for the node pool.
     * NOTE: Set the "desired_node_pool" field as well.
     * </pre>
     *
     * <code>optional string desired_image_type = 8;</code>
     */
    public java.lang.String getDesiredImageType() {
      return instance.getDesiredImageType();
    }
    /**
     * <pre>
     * The desired image type for the node pool.
     * NOTE: Set the "desired_node_pool" field as well.
     * </pre>
     *
     * <code>optional string desired_image_type = 8;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredImageTypeBytes() {
      return instance.getDesiredImageTypeBytes();
    }
    /**
     * <pre>
     * The desired image type for the node pool.
     * NOTE: Set the "desired_node_pool" field as well.
     * </pre>
     *
     * <code>optional string desired_image_type = 8;</code>
     */
    public Builder setDesiredImageType(
        java.lang.String value) {
      copyOnWrite();
      instance.setDesiredImageType(value);
      return this;
    }
    /**
     * <pre>
     * The desired image type for the node pool.
     * NOTE: Set the "desired_node_pool" field as well.
     * </pre>
     *
     * <code>optional string desired_image_type = 8;</code>
     */
    public Builder clearDesiredImageType() {
      copyOnWrite();
      instance.clearDesiredImageType();
      return this;
    }
    /**
     * <pre>
     * The desired image type for the node pool.
     * NOTE: Set the "desired_node_pool" field as well.
     * </pre>
     *
     * <code>optional string desired_image_type = 8;</code>
     */
    public Builder setDesiredImageTypeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDesiredImageTypeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Autoscaler configuration for the node pool specified in
     * desired_node_pool_id. If there is only one pool in the
     * cluster and desired_node_pool_id is not provided then
     * the change applies to that single node pool.
     * </pre>
     *
     * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
     */
    public boolean hasDesiredNodePoolAutoscaling() {
      return instance.hasDesiredNodePoolAutoscaling();
    }
    /**
     * <pre>
     * Autoscaler configuration for the node pool specified in
     * desired_node_pool_id. If there is only one pool in the
     * cluster and desired_node_pool_id is not provided then
     * the change applies to that single node pool.
     * </pre>
     *
     * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
     */
    public com.google.container.v1.NodePoolAutoscaling getDesiredNodePoolAutoscaling() {
      return instance.getDesiredNodePoolAutoscaling();
    }
    /**
     * <pre>
     * Autoscaler configuration for the node pool specified in
     * desired_node_pool_id. If there is only one pool in the
     * cluster and desired_node_pool_id is not provided then
     * the change applies to that single node pool.
     * </pre>
     *
     * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
     */
    public Builder setDesiredNodePoolAutoscaling(com.google.container.v1.NodePoolAutoscaling value) {
      copyOnWrite();
      instance.setDesiredNodePoolAutoscaling(value);
      return this;
      }
    /**
     * <pre>
     * Autoscaler configuration for the node pool specified in
     * desired_node_pool_id. If there is only one pool in the
     * cluster and desired_node_pool_id is not provided then
     * the change applies to that single node pool.
     * </pre>
     *
     * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
     */
    public Builder setDesiredNodePoolAutoscaling(
        com.google.container.v1.NodePoolAutoscaling.Builder builderForValue) {
      copyOnWrite();
      instance.setDesiredNodePoolAutoscaling(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Autoscaler configuration for the node pool specified in
     * desired_node_pool_id. If there is only one pool in the
     * cluster and desired_node_pool_id is not provided then
     * the change applies to that single node pool.
     * </pre>
     *
     * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
     */
    public Builder mergeDesiredNodePoolAutoscaling(com.google.container.v1.NodePoolAutoscaling value) {
      copyOnWrite();
      instance.mergeDesiredNodePoolAutoscaling(value);
      return this;
    }
    /**
     * <pre>
     * Autoscaler configuration for the node pool specified in
     * desired_node_pool_id. If there is only one pool in the
     * cluster and desired_node_pool_id is not provided then
     * the change applies to that single node pool.
     * </pre>
     *
     * <code>optional .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;</code>
     */
    public Builder clearDesiredNodePoolAutoscaling() {  copyOnWrite();
      instance.clearDesiredNodePoolAutoscaling();
      return this;
    }

    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public java.util.List<String>
        getDesiredLocationsList() {
      return java.util.Collections.unmodifiableList(
          instance.getDesiredLocationsList());
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public int getDesiredLocationsCount() {
      return instance.getDesiredLocationsCount();
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public java.lang.String getDesiredLocations(int index) {
      return instance.getDesiredLocations(index);
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredLocationsBytes(int index) {
      return instance.getDesiredLocationsBytes(index);
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public Builder setDesiredLocations(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setDesiredLocations(index, value);
      return this;
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public Builder addDesiredLocations(
        java.lang.String value) {
      copyOnWrite();
      instance.addDesiredLocations(value);
      return this;
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public Builder addAllDesiredLocations(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllDesiredLocations(values);
      return this;
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public Builder clearDesiredLocations() {
      copyOnWrite();
      instance.clearDesiredLocations();
      return this;
    }
    /**
     * <pre>
     * The desired list of Google Compute Engine
     * [locations](/compute/docs/zones#available) in which the cluster's nodes
     * should be located. Changing the locations a cluster is in will result
     * in nodes being either created or removed from the cluster, depending on
     * whether locations are being added or removed.
     * This list must always include the cluster's primary zone.
     * </pre>
     *
     * <code>repeated string desired_locations = 10;</code>
     */
    public Builder addDesiredLocationsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addDesiredLocationsBytes(value);
      return this;
    }

    /**
     * <pre>
     * The Kubernetes version to change the master to. The only valid value is the
     * latest supported version. Use "-" to have the server automatically select
     * the latest version.
     * </pre>
     *
     * <code>optional string desired_master_version = 100;</code>
     */
    public java.lang.String getDesiredMasterVersion() {
      return instance.getDesiredMasterVersion();
    }
    /**
     * <pre>
     * The Kubernetes version to change the master to. The only valid value is the
     * latest supported version. Use "-" to have the server automatically select
     * the latest version.
     * </pre>
     *
     * <code>optional string desired_master_version = 100;</code>
     */
    public com.google.protobuf.ByteString
        getDesiredMasterVersionBytes() {
      return instance.getDesiredMasterVersionBytes();
    }
    /**
     * <pre>
     * The Kubernetes version to change the master to. The only valid value is the
     * latest supported version. Use "-" to have the server automatically select
     * the latest version.
     * </pre>
     *
     * <code>optional string desired_master_version = 100;</code>
     */
    public Builder setDesiredMasterVersion(
        java.lang.String value) {
      copyOnWrite();
      instance.setDesiredMasterVersion(value);
      return this;
    }
    /**
     * <pre>
     * The Kubernetes version to change the master to. The only valid value is the
     * latest supported version. Use "-" to have the server automatically select
     * the latest version.
     * </pre>
     *
     * <code>optional string desired_master_version = 100;</code>
     */
    public Builder clearDesiredMasterVersion() {
      copyOnWrite();
      instance.clearDesiredMasterVersion();
      return this;
    }
    /**
     * <pre>
     * The Kubernetes version to change the master to. The only valid value is the
     * latest supported version. Use "-" to have the server automatically select
     * the latest version.
     * </pre>
     *
     * <code>optional string desired_master_version = 100;</code>
     */
    public Builder setDesiredMasterVersionBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setDesiredMasterVersionBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.container.v1.ClusterUpdate)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.container.v1.ClusterUpdate();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        desiredLocations_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        com.google.container.v1.ClusterUpdate other = (com.google.container.v1.ClusterUpdate) arg1;
        desiredNodeVersion_ = visitor.visitString(!desiredNodeVersion_.isEmpty(), desiredNodeVersion_,
            !other.desiredNodeVersion_.isEmpty(), other.desiredNodeVersion_);
        desiredMonitoringService_ = visitor.visitString(!desiredMonitoringService_.isEmpty(), desiredMonitoringService_,
            !other.desiredMonitoringService_.isEmpty(), other.desiredMonitoringService_);
        desiredAddonsConfig_ = visitor.visitMessage(desiredAddonsConfig_, other.desiredAddonsConfig_);
        desiredNodePoolId_ = visitor.visitString(!desiredNodePoolId_.isEmpty(), desiredNodePoolId_,
            !other.desiredNodePoolId_.isEmpty(), other.desiredNodePoolId_);
        desiredImageType_ = visitor.visitString(!desiredImageType_.isEmpty(), desiredImageType_,
            !other.desiredImageType_.isEmpty(), other.desiredImageType_);
        desiredNodePoolAutoscaling_ = visitor.visitMessage(desiredNodePoolAutoscaling_, other.desiredNodePoolAutoscaling_);
        desiredLocations_= visitor.visitList(desiredLocations_, other.desiredLocations_);
        desiredMasterVersion_ = visitor.visitString(!desiredMasterVersion_.isEmpty(), desiredMasterVersion_,
            !other.desiredMasterVersion_.isEmpty(), other.desiredMasterVersion_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 34: {
                String s = input.readStringRequireUtf8();

                desiredNodeVersion_ = s;
                break;
              }
              case 42: {
                String s = input.readStringRequireUtf8();

                desiredMonitoringService_ = s;
                break;
              }
              case 50: {
                com.google.container.v1.AddonsConfig.Builder subBuilder = null;
                if (desiredAddonsConfig_ != null) {
                  subBuilder = desiredAddonsConfig_.toBuilder();
                }
                desiredAddonsConfig_ = input.readMessage(com.google.container.v1.AddonsConfig.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(desiredAddonsConfig_);
                  desiredAddonsConfig_ = subBuilder.buildPartial();
                }

                break;
              }
              case 58: {
                String s = input.readStringRequireUtf8();

                desiredNodePoolId_ = s;
                break;
              }
              case 66: {
                String s = input.readStringRequireUtf8();

                desiredImageType_ = s;
                break;
              }
              case 74: {
                com.google.container.v1.NodePoolAutoscaling.Builder subBuilder = null;
                if (desiredNodePoolAutoscaling_ != null) {
                  subBuilder = desiredNodePoolAutoscaling_.toBuilder();
                }
                desiredNodePoolAutoscaling_ = input.readMessage(com.google.container.v1.NodePoolAutoscaling.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(desiredNodePoolAutoscaling_);
                  desiredNodePoolAutoscaling_ = subBuilder.buildPartial();
                }

                break;
              }
              case 82: {
                String s = input.readStringRequireUtf8();
                if (!desiredLocations_.isModifiable()) {
                  desiredLocations_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(desiredLocations_);
                }
                desiredLocations_.add(s);
                break;
              }
              case 802: {
                String s = input.readStringRequireUtf8();

                desiredMasterVersion_ = s;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (com.google.container.v1.ClusterUpdate.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.container.v1.ClusterUpdate)
  private static final com.google.container.v1.ClusterUpdate DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new ClusterUpdate();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static com.google.container.v1.ClusterUpdate getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<ClusterUpdate> PARSER;

  public static com.google.protobuf.Parser<ClusterUpdate> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

