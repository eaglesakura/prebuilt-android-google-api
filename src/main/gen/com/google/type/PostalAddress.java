// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/type/postal_address.proto

package com.google.type;

/**
 * <pre>
 * Represents a postal address, e.g. for postal delivery or payments addresses.
 * Given a postal address, a postal service can deliver items to a premise, P.O.
 * Box or similar.
 * It is not intended to model geographical locations (roads, towns,
 * mountains).
 * In typical usage an address would be created via user input or from importing
 * existing data, depending on the type of process.
 * Advice on address input / editing:
 *  - Use an i18n-ready address widget such as
 *    https://github.com/googlei18n/libaddressinput)
 * - Users should not be presented with UI elements for input or editing of
 *   fields outside countries where that field is used.
 * For more guidance on how to use this schema, please see:
 * https://support.google.com/business/answer/6397478
 * </pre>
 *
 * Protobuf type {@code google.type.PostalAddress}
 */
public  final class PostalAddress extends
    com.google.protobuf.GeneratedMessageLite<
        PostalAddress, PostalAddress.Builder> implements
    // @@protoc_insertion_point(message_implements:google.type.PostalAddress)
    PostalAddressOrBuilder {
  private PostalAddress() {
    regionCode_ = "";
    languageCode_ = "";
    postalCode_ = "";
    sortingCode_ = "";
    administrativeArea_ = "";
    locality_ = "";
    sublocality_ = "";
    addressLines_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    recipients_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    organization_ = "";
  }
  private int bitField0_;
  public static final int REVISION_FIELD_NUMBER = 1;
  private int revision_;
  /**
   * <pre>
   * The schema revision of the `PostalAddress`.
   * All new revisions **must** be backward compatible with old revisions.
   * </pre>
   *
   * <code>optional int32 revision = 1;</code>
   */
  public int getRevision() {
    return revision_;
  }
  /**
   * <pre>
   * The schema revision of the `PostalAddress`.
   * All new revisions **must** be backward compatible with old revisions.
   * </pre>
   *
   * <code>optional int32 revision = 1;</code>
   */
  private void setRevision(int value) {
    
    revision_ = value;
  }
  /**
   * <pre>
   * The schema revision of the `PostalAddress`.
   * All new revisions **must** be backward compatible with old revisions.
   * </pre>
   *
   * <code>optional int32 revision = 1;</code>
   */
  private void clearRevision() {
    
    revision_ = 0;
  }

  public static final int REGION_CODE_FIELD_NUMBER = 2;
  private java.lang.String regionCode_;
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>optional string region_code = 2;</code>
   */
  public java.lang.String getRegionCode() {
    return regionCode_;
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>optional string region_code = 2;</code>
   */
  public com.google.protobuf.ByteString
      getRegionCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(regionCode_);
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>optional string region_code = 2;</code>
   */
  private void setRegionCode(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    regionCode_ = value;
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>optional string region_code = 2;</code>
   */
  private void clearRegionCode() {
    
    regionCode_ = getDefaultInstance().getRegionCode();
  }
  /**
   * <pre>
   * Required. CLDR region code of the country/region of the address. This
   * is never inferred and it is up to the user to ensure the value is
   * correct. See http://cldr.unicode.org/ and
   * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
   * for details. Example: "CH" for Switzerland.
   * </pre>
   *
   * <code>optional string region_code = 2;</code>
   */
  private void setRegionCodeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    regionCode_ = value.toStringUtf8();
  }

  public static final int LANGUAGE_CODE_FIELD_NUMBER = 3;
  private java.lang.String languageCode_;
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>optional string language_code = 3;</code>
   */
  public java.lang.String getLanguageCode() {
    return languageCode_;
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>optional string language_code = 3;</code>
   */
  public com.google.protobuf.ByteString
      getLanguageCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(languageCode_);
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>optional string language_code = 3;</code>
   */
  private void setLanguageCode(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    languageCode_ = value;
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>optional string language_code = 3;</code>
   */
  private void clearLanguageCode() {
    
    languageCode_ = getDefaultInstance().getLanguageCode();
  }
  /**
   * <pre>
   * Optional. BCP-47 language code of the contents of this address (if
   * known). This is often the UI language of the input form or is expected
   * to match one of the languages used in the address' country/region, or their
   * transliterated equivalents.
   * This can affect formatting in certain countries, but is not critical
   * to the correctness of the data and will never affect any validation or
   * other non-formatting related operations.
   * If this value is not known, it should be omitted (rather than specifying a
   * possibly incorrect default).
   * Examples: "zh-Hant", "ja", "ja-Latn", "en".
   * </pre>
   *
   * <code>optional string language_code = 3;</code>
   */
  private void setLanguageCodeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    languageCode_ = value.toStringUtf8();
  }

  public static final int POSTAL_CODE_FIELD_NUMBER = 4;
  private java.lang.String postalCode_;
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>optional string postal_code = 4;</code>
   */
  public java.lang.String getPostalCode() {
    return postalCode_;
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>optional string postal_code = 4;</code>
   */
  public com.google.protobuf.ByteString
      getPostalCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(postalCode_);
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>optional string postal_code = 4;</code>
   */
  private void setPostalCode(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    postalCode_ = value;
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>optional string postal_code = 4;</code>
   */
  private void clearPostalCode() {
    
    postalCode_ = getDefaultInstance().getPostalCode();
  }
  /**
   * <pre>
   * Optional. Postal code of the address. Not all countries use or require
   * postal codes to be present, but where they are used, they may trigger
   * additional validation with other parts of the address (e.g. state/zip
   * validation in the U.S.A.).
   * </pre>
   *
   * <code>optional string postal_code = 4;</code>
   */
  private void setPostalCodeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    postalCode_ = value.toStringUtf8();
  }

  public static final int SORTING_CODE_FIELD_NUMBER = 5;
  private java.lang.String sortingCode_;
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>optional string sorting_code = 5;</code>
   */
  public java.lang.String getSortingCode() {
    return sortingCode_;
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>optional string sorting_code = 5;</code>
   */
  public com.google.protobuf.ByteString
      getSortingCodeBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(sortingCode_);
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>optional string sorting_code = 5;</code>
   */
  private void setSortingCode(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    sortingCode_ = value;
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>optional string sorting_code = 5;</code>
   */
  private void clearSortingCode() {
    
    sortingCode_ = getDefaultInstance().getSortingCode();
  }
  /**
   * <pre>
   * Optional. Additional, country-specific, sorting code. This is not used
   * in most regions. Where it is used, the value is either a string like
   * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
   * alone, representing the "sector code" (Jamaica), "delivery area indicator"
   * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
   * </pre>
   *
   * <code>optional string sorting_code = 5;</code>
   */
  private void setSortingCodeBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    sortingCode_ = value.toStringUtf8();
  }

  public static final int ADMINISTRATIVE_AREA_FIELD_NUMBER = 6;
  private java.lang.String administrativeArea_;
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>optional string administrative_area = 6;</code>
   */
  public java.lang.String getAdministrativeArea() {
    return administrativeArea_;
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>optional string administrative_area = 6;</code>
   */
  public com.google.protobuf.ByteString
      getAdministrativeAreaBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(administrativeArea_);
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>optional string administrative_area = 6;</code>
   */
  private void setAdministrativeArea(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    administrativeArea_ = value;
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>optional string administrative_area = 6;</code>
   */
  private void clearAdministrativeArea() {
    
    administrativeArea_ = getDefaultInstance().getAdministrativeArea();
  }
  /**
   * <pre>
   * Optional. Highest administrative subdivision which is used for postal
   * addresses of a country or region.
   * For example, this can be a state, a province, an oblast, or a prefecture.
   * Specifically, for Spain this is the province and not the autonomous
   * community (e.g. "Barcelona" and not "Catalonia").
   * Many countries don't use an administrative area in postal addresses. E.g.
   * in Switzerland this should be left unpopulated.
   * </pre>
   *
   * <code>optional string administrative_area = 6;</code>
   */
  private void setAdministrativeAreaBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    administrativeArea_ = value.toStringUtf8();
  }

  public static final int LOCALITY_FIELD_NUMBER = 7;
  private java.lang.String locality_;
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>optional string locality = 7;</code>
   */
  public java.lang.String getLocality() {
    return locality_;
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>optional string locality = 7;</code>
   */
  public com.google.protobuf.ByteString
      getLocalityBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(locality_);
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>optional string locality = 7;</code>
   */
  private void setLocality(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    locality_ = value;
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>optional string locality = 7;</code>
   */
  private void clearLocality() {
    
    locality_ = getDefaultInstance().getLocality();
  }
  /**
   * <pre>
   * Optional. Generally refers to the city/town portion of the address.
   * Examples: US city, IT comune, UK post town.
   * In regions of the world where localities are not well defined or do not fit
   * into this structure well, leave locality empty and use address_lines.
   * </pre>
   *
   * <code>optional string locality = 7;</code>
   */
  private void setLocalityBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    locality_ = value.toStringUtf8();
  }

  public static final int SUBLOCALITY_FIELD_NUMBER = 8;
  private java.lang.String sublocality_;
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>optional string sublocality = 8;</code>
   */
  public java.lang.String getSublocality() {
    return sublocality_;
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>optional string sublocality = 8;</code>
   */
  public com.google.protobuf.ByteString
      getSublocalityBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(sublocality_);
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>optional string sublocality = 8;</code>
   */
  private void setSublocality(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    sublocality_ = value;
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>optional string sublocality = 8;</code>
   */
  private void clearSublocality() {
    
    sublocality_ = getDefaultInstance().getSublocality();
  }
  /**
   * <pre>
   * Optional. Sublocality of the address.
   * For example, this can be neighborhoods, boroughs, districts.
   * </pre>
   *
   * <code>optional string sublocality = 8;</code>
   */
  private void setSublocalityBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    sublocality_ = value.toStringUtf8();
  }

  public static final int ADDRESS_LINES_FIELD_NUMBER = 9;
  private com.google.protobuf.Internal.ProtobufList<String> addressLines_;
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  public java.util.List<String> getAddressLinesList() {
    return addressLines_;
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  public int getAddressLinesCount() {
    return addressLines_.size();
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  public java.lang.String getAddressLines(int index) {
    return addressLines_.get(index);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  public com.google.protobuf.ByteString
      getAddressLinesBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        addressLines_.get(index));
  }
  private void ensureAddressLinesIsMutable() {
    if (!addressLines_.isModifiable()) {
      addressLines_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(addressLines_);
     }
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  private void setAddressLines(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureAddressLinesIsMutable();
    addressLines_.set(index, value);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  private void addAddressLines(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureAddressLinesIsMutable();
    addressLines_.add(value);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  private void addAllAddressLines(
      java.lang.Iterable<java.lang.String> values) {
    ensureAddressLinesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, addressLines_);
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  private void clearAddressLines() {
    addressLines_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * Unstructured address lines describing the lower levels of an address.
   * Because values in address_lines do not have type information and may
   * sometimes contain multiple values in a single field (e.g.
   * "Austin, TX"), it is important that the line order is clear. The order of
   * address lines should be "envelope order" for the country/region of the
   * address. In places where this can vary (e.g. Japan), address_language is
   * used to make it explicit (e.g. "ja" for large-to-small ordering and
   * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
   * an address can be selected based on the language.
   * The minimum permitted structural representation of an address consists
   * of a region_code with all remaining information placed in the
   * address_lines. It would be possible to format such an address very
   * approximately without geocoding, but no semantic reasoning could be
   * made about any of the address components until it was at least
   * partially resolved.
   * Creating an address only containing a region_code and address_lines, and
   * then geocoding is the recommended way to handle completely unstructured
   * addresses (as opposed to guessing which parts of the address should be
   * localities or administrative areas).
   * </pre>
   *
   * <code>repeated string address_lines = 9;</code>
   */
  private void addAddressLinesBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureAddressLinesIsMutable();
    addressLines_.add(value.toStringUtf8());
  }

  public static final int RECIPIENTS_FIELD_NUMBER = 10;
  private com.google.protobuf.Internal.ProtobufList<String> recipients_;
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  public java.util.List<String> getRecipientsList() {
    return recipients_;
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  public int getRecipientsCount() {
    return recipients_.size();
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  public java.lang.String getRecipients(int index) {
    return recipients_.get(index);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  public com.google.protobuf.ByteString
      getRecipientsBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        recipients_.get(index));
  }
  private void ensureRecipientsIsMutable() {
    if (!recipients_.isModifiable()) {
      recipients_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(recipients_);
     }
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  private void setRecipients(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureRecipientsIsMutable();
    recipients_.set(index, value);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  private void addRecipients(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureRecipientsIsMutable();
    recipients_.add(value);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  private void addAllRecipients(
      java.lang.Iterable<java.lang.String> values) {
    ensureRecipientsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, recipients_);
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  private void clearRecipients() {
    recipients_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * Optional. The recipient at the address.
   * This field may, under certain circumstances, contain multiline information.
   * For example, it might contain "care of" information.
   * </pre>
   *
   * <code>repeated string recipients = 10;</code>
   */
  private void addRecipientsBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    ensureRecipientsIsMutable();
    recipients_.add(value.toStringUtf8());
  }

  public static final int ORGANIZATION_FIELD_NUMBER = 11;
  private java.lang.String organization_;
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>optional string organization = 11;</code>
   */
  public java.lang.String getOrganization() {
    return organization_;
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>optional string organization = 11;</code>
   */
  public com.google.protobuf.ByteString
      getOrganizationBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(organization_);
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>optional string organization = 11;</code>
   */
  private void setOrganization(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  
    organization_ = value;
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>optional string organization = 11;</code>
   */
  private void clearOrganization() {
    
    organization_ = getDefaultInstance().getOrganization();
  }
  /**
   * <pre>
   * Optional. The name of the organization at the address.
   * </pre>
   *
   * <code>optional string organization = 11;</code>
   */
  private void setOrganizationBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
    
    organization_ = value.toStringUtf8();
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (revision_ != 0) {
      output.writeInt32(1, revision_);
    }
    if (!regionCode_.isEmpty()) {
      output.writeString(2, getRegionCode());
    }
    if (!languageCode_.isEmpty()) {
      output.writeString(3, getLanguageCode());
    }
    if (!postalCode_.isEmpty()) {
      output.writeString(4, getPostalCode());
    }
    if (!sortingCode_.isEmpty()) {
      output.writeString(5, getSortingCode());
    }
    if (!administrativeArea_.isEmpty()) {
      output.writeString(6, getAdministrativeArea());
    }
    if (!locality_.isEmpty()) {
      output.writeString(7, getLocality());
    }
    if (!sublocality_.isEmpty()) {
      output.writeString(8, getSublocality());
    }
    for (int i = 0; i < addressLines_.size(); i++) {
      output.writeString(9, addressLines_.get(i));
    }
    for (int i = 0; i < recipients_.size(); i++) {
      output.writeString(10, recipients_.get(i));
    }
    if (!organization_.isEmpty()) {
      output.writeString(11, getOrganization());
    }
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (revision_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(1, revision_);
    }
    if (!regionCode_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(2, getRegionCode());
    }
    if (!languageCode_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(3, getLanguageCode());
    }
    if (!postalCode_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(4, getPostalCode());
    }
    if (!sortingCode_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(5, getSortingCode());
    }
    if (!administrativeArea_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(6, getAdministrativeArea());
    }
    if (!locality_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(7, getLocality());
    }
    if (!sublocality_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(8, getSublocality());
    }
    {
      int dataSize = 0;
      for (int i = 0; i < addressLines_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(addressLines_.get(i));
      }
      size += dataSize;
      size += 1 * getAddressLinesList().size();
    }
    {
      int dataSize = 0;
      for (int i = 0; i < recipients_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(recipients_.get(i));
      }
      size += dataSize;
      size += 1 * getRecipientsList().size();
    }
    if (!organization_.isEmpty()) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(11, getOrganization());
    }
    memoizedSerializedSize = size;
    return size;
  }

  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static com.google.type.PostalAddress parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.type.PostalAddress parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static com.google.type.PostalAddress parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static com.google.type.PostalAddress parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.type.PostalAddress prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * Represents a postal address, e.g. for postal delivery or payments addresses.
   * Given a postal address, a postal service can deliver items to a premise, P.O.
   * Box or similar.
   * It is not intended to model geographical locations (roads, towns,
   * mountains).
   * In typical usage an address would be created via user input or from importing
   * existing data, depending on the type of process.
   * Advice on address input / editing:
   *  - Use an i18n-ready address widget such as
   *    https://github.com/googlei18n/libaddressinput)
   * - Users should not be presented with UI elements for input or editing of
   *   fields outside countries where that field is used.
   * For more guidance on how to use this schema, please see:
   * https://support.google.com/business/answer/6397478
   * </pre>
   *
   * Protobuf type {@code google.type.PostalAddress}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        com.google.type.PostalAddress, Builder> implements
      // @@protoc_insertion_point(builder_implements:google.type.PostalAddress)
      com.google.type.PostalAddressOrBuilder {
    // Construct using com.google.type.PostalAddress.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The schema revision of the `PostalAddress`.
     * All new revisions **must** be backward compatible with old revisions.
     * </pre>
     *
     * <code>optional int32 revision = 1;</code>
     */
    public int getRevision() {
      return instance.getRevision();
    }
    /**
     * <pre>
     * The schema revision of the `PostalAddress`.
     * All new revisions **must** be backward compatible with old revisions.
     * </pre>
     *
     * <code>optional int32 revision = 1;</code>
     */
    public Builder setRevision(int value) {
      copyOnWrite();
      instance.setRevision(value);
      return this;
    }
    /**
     * <pre>
     * The schema revision of the `PostalAddress`.
     * All new revisions **must** be backward compatible with old revisions.
     * </pre>
     *
     * <code>optional int32 revision = 1;</code>
     */
    public Builder clearRevision() {
      copyOnWrite();
      instance.clearRevision();
      return this;
    }

    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>optional string region_code = 2;</code>
     */
    public java.lang.String getRegionCode() {
      return instance.getRegionCode();
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>optional string region_code = 2;</code>
     */
    public com.google.protobuf.ByteString
        getRegionCodeBytes() {
      return instance.getRegionCodeBytes();
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>optional string region_code = 2;</code>
     */
    public Builder setRegionCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setRegionCode(value);
      return this;
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>optional string region_code = 2;</code>
     */
    public Builder clearRegionCode() {
      copyOnWrite();
      instance.clearRegionCode();
      return this;
    }
    /**
     * <pre>
     * Required. CLDR region code of the country/region of the address. This
     * is never inferred and it is up to the user to ensure the value is
     * correct. See http://cldr.unicode.org/ and
     * http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
     * for details. Example: "CH" for Switzerland.
     * </pre>
     *
     * <code>optional string region_code = 2;</code>
     */
    public Builder setRegionCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setRegionCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>optional string language_code = 3;</code>
     */
    public java.lang.String getLanguageCode() {
      return instance.getLanguageCode();
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>optional string language_code = 3;</code>
     */
    public com.google.protobuf.ByteString
        getLanguageCodeBytes() {
      return instance.getLanguageCodeBytes();
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>optional string language_code = 3;</code>
     */
    public Builder setLanguageCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setLanguageCode(value);
      return this;
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>optional string language_code = 3;</code>
     */
    public Builder clearLanguageCode() {
      copyOnWrite();
      instance.clearLanguageCode();
      return this;
    }
    /**
     * <pre>
     * Optional. BCP-47 language code of the contents of this address (if
     * known). This is often the UI language of the input form or is expected
     * to match one of the languages used in the address' country/region, or their
     * transliterated equivalents.
     * This can affect formatting in certain countries, but is not critical
     * to the correctness of the data and will never affect any validation or
     * other non-formatting related operations.
     * If this value is not known, it should be omitted (rather than specifying a
     * possibly incorrect default).
     * Examples: "zh-Hant", "ja", "ja-Latn", "en".
     * </pre>
     *
     * <code>optional string language_code = 3;</code>
     */
    public Builder setLanguageCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLanguageCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>optional string postal_code = 4;</code>
     */
    public java.lang.String getPostalCode() {
      return instance.getPostalCode();
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>optional string postal_code = 4;</code>
     */
    public com.google.protobuf.ByteString
        getPostalCodeBytes() {
      return instance.getPostalCodeBytes();
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>optional string postal_code = 4;</code>
     */
    public Builder setPostalCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setPostalCode(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>optional string postal_code = 4;</code>
     */
    public Builder clearPostalCode() {
      copyOnWrite();
      instance.clearPostalCode();
      return this;
    }
    /**
     * <pre>
     * Optional. Postal code of the address. Not all countries use or require
     * postal codes to be present, but where they are used, they may trigger
     * additional validation with other parts of the address (e.g. state/zip
     * validation in the U.S.A.).
     * </pre>
     *
     * <code>optional string postal_code = 4;</code>
     */
    public Builder setPostalCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setPostalCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>optional string sorting_code = 5;</code>
     */
    public java.lang.String getSortingCode() {
      return instance.getSortingCode();
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>optional string sorting_code = 5;</code>
     */
    public com.google.protobuf.ByteString
        getSortingCodeBytes() {
      return instance.getSortingCodeBytes();
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>optional string sorting_code = 5;</code>
     */
    public Builder setSortingCode(
        java.lang.String value) {
      copyOnWrite();
      instance.setSortingCode(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>optional string sorting_code = 5;</code>
     */
    public Builder clearSortingCode() {
      copyOnWrite();
      instance.clearSortingCode();
      return this;
    }
    /**
     * <pre>
     * Optional. Additional, country-specific, sorting code. This is not used
     * in most regions. Where it is used, the value is either a string like
     * "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
     * alone, representing the "sector code" (Jamaica), "delivery area indicator"
     * (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
     * </pre>
     *
     * <code>optional string sorting_code = 5;</code>
     */
    public Builder setSortingCodeBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSortingCodeBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>optional string administrative_area = 6;</code>
     */
    public java.lang.String getAdministrativeArea() {
      return instance.getAdministrativeArea();
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>optional string administrative_area = 6;</code>
     */
    public com.google.protobuf.ByteString
        getAdministrativeAreaBytes() {
      return instance.getAdministrativeAreaBytes();
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>optional string administrative_area = 6;</code>
     */
    public Builder setAdministrativeArea(
        java.lang.String value) {
      copyOnWrite();
      instance.setAdministrativeArea(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>optional string administrative_area = 6;</code>
     */
    public Builder clearAdministrativeArea() {
      copyOnWrite();
      instance.clearAdministrativeArea();
      return this;
    }
    /**
     * <pre>
     * Optional. Highest administrative subdivision which is used for postal
     * addresses of a country or region.
     * For example, this can be a state, a province, an oblast, or a prefecture.
     * Specifically, for Spain this is the province and not the autonomous
     * community (e.g. "Barcelona" and not "Catalonia").
     * Many countries don't use an administrative area in postal addresses. E.g.
     * in Switzerland this should be left unpopulated.
     * </pre>
     *
     * <code>optional string administrative_area = 6;</code>
     */
    public Builder setAdministrativeAreaBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setAdministrativeAreaBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>optional string locality = 7;</code>
     */
    public java.lang.String getLocality() {
      return instance.getLocality();
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>optional string locality = 7;</code>
     */
    public com.google.protobuf.ByteString
        getLocalityBytes() {
      return instance.getLocalityBytes();
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>optional string locality = 7;</code>
     */
    public Builder setLocality(
        java.lang.String value) {
      copyOnWrite();
      instance.setLocality(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>optional string locality = 7;</code>
     */
    public Builder clearLocality() {
      copyOnWrite();
      instance.clearLocality();
      return this;
    }
    /**
     * <pre>
     * Optional. Generally refers to the city/town portion of the address.
     * Examples: US city, IT comune, UK post town.
     * In regions of the world where localities are not well defined or do not fit
     * into this structure well, leave locality empty and use address_lines.
     * </pre>
     *
     * <code>optional string locality = 7;</code>
     */
    public Builder setLocalityBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLocalityBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>optional string sublocality = 8;</code>
     */
    public java.lang.String getSublocality() {
      return instance.getSublocality();
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>optional string sublocality = 8;</code>
     */
    public com.google.protobuf.ByteString
        getSublocalityBytes() {
      return instance.getSublocalityBytes();
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>optional string sublocality = 8;</code>
     */
    public Builder setSublocality(
        java.lang.String value) {
      copyOnWrite();
      instance.setSublocality(value);
      return this;
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>optional string sublocality = 8;</code>
     */
    public Builder clearSublocality() {
      copyOnWrite();
      instance.clearSublocality();
      return this;
    }
    /**
     * <pre>
     * Optional. Sublocality of the address.
     * For example, this can be neighborhoods, boroughs, districts.
     * </pre>
     *
     * <code>optional string sublocality = 8;</code>
     */
    public Builder setSublocalityBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSublocalityBytes(value);
      return this;
    }

    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public java.util.List<String>
        getAddressLinesList() {
      return java.util.Collections.unmodifiableList(
          instance.getAddressLinesList());
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public int getAddressLinesCount() {
      return instance.getAddressLinesCount();
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public java.lang.String getAddressLines(int index) {
      return instance.getAddressLines(index);
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public com.google.protobuf.ByteString
        getAddressLinesBytes(int index) {
      return instance.getAddressLinesBytes(index);
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public Builder setAddressLines(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setAddressLines(index, value);
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public Builder addAddressLines(
        java.lang.String value) {
      copyOnWrite();
      instance.addAddressLines(value);
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public Builder addAllAddressLines(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllAddressLines(values);
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public Builder clearAddressLines() {
      copyOnWrite();
      instance.clearAddressLines();
      return this;
    }
    /**
     * <pre>
     * Unstructured address lines describing the lower levels of an address.
     * Because values in address_lines do not have type information and may
     * sometimes contain multiple values in a single field (e.g.
     * "Austin, TX"), it is important that the line order is clear. The order of
     * address lines should be "envelope order" for the country/region of the
     * address. In places where this can vary (e.g. Japan), address_language is
     * used to make it explicit (e.g. "ja" for large-to-small ordering and
     * "ja-Latn" or "en" for small-to-large). This way, the most specific line of
     * an address can be selected based on the language.
     * The minimum permitted structural representation of an address consists
     * of a region_code with all remaining information placed in the
     * address_lines. It would be possible to format such an address very
     * approximately without geocoding, but no semantic reasoning could be
     * made about any of the address components until it was at least
     * partially resolved.
     * Creating an address only containing a region_code and address_lines, and
     * then geocoding is the recommended way to handle completely unstructured
     * addresses (as opposed to guessing which parts of the address should be
     * localities or administrative areas).
     * </pre>
     *
     * <code>repeated string address_lines = 9;</code>
     */
    public Builder addAddressLinesBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addAddressLinesBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public java.util.List<String>
        getRecipientsList() {
      return java.util.Collections.unmodifiableList(
          instance.getRecipientsList());
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public int getRecipientsCount() {
      return instance.getRecipientsCount();
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public java.lang.String getRecipients(int index) {
      return instance.getRecipients(index);
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public com.google.protobuf.ByteString
        getRecipientsBytes(int index) {
      return instance.getRecipientsBytes(index);
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public Builder setRecipients(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setRecipients(index, value);
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public Builder addRecipients(
        java.lang.String value) {
      copyOnWrite();
      instance.addRecipients(value);
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public Builder addAllRecipients(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllRecipients(values);
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public Builder clearRecipients() {
      copyOnWrite();
      instance.clearRecipients();
      return this;
    }
    /**
     * <pre>
     * Optional. The recipient at the address.
     * This field may, under certain circumstances, contain multiline information.
     * For example, it might contain "care of" information.
     * </pre>
     *
     * <code>repeated string recipients = 10;</code>
     */
    public Builder addRecipientsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addRecipientsBytes(value);
      return this;
    }

    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>optional string organization = 11;</code>
     */
    public java.lang.String getOrganization() {
      return instance.getOrganization();
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>optional string organization = 11;</code>
     */
    public com.google.protobuf.ByteString
        getOrganizationBytes() {
      return instance.getOrganizationBytes();
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>optional string organization = 11;</code>
     */
    public Builder setOrganization(
        java.lang.String value) {
      copyOnWrite();
      instance.setOrganization(value);
      return this;
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>optional string organization = 11;</code>
     */
    public Builder clearOrganization() {
      copyOnWrite();
      instance.clearOrganization();
      return this;
    }
    /**
     * <pre>
     * Optional. The name of the organization at the address.
     * </pre>
     *
     * <code>optional string organization = 11;</code>
     */
    public Builder setOrganizationBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOrganizationBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.type.PostalAddress)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new com.google.type.PostalAddress();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        addressLines_.makeImmutable();
        recipients_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        com.google.type.PostalAddress other = (com.google.type.PostalAddress) arg1;
        revision_ = visitor.visitInt(revision_ != 0, revision_,
            other.revision_ != 0, other.revision_);
        regionCode_ = visitor.visitString(!regionCode_.isEmpty(), regionCode_,
            !other.regionCode_.isEmpty(), other.regionCode_);
        languageCode_ = visitor.visitString(!languageCode_.isEmpty(), languageCode_,
            !other.languageCode_.isEmpty(), other.languageCode_);
        postalCode_ = visitor.visitString(!postalCode_.isEmpty(), postalCode_,
            !other.postalCode_.isEmpty(), other.postalCode_);
        sortingCode_ = visitor.visitString(!sortingCode_.isEmpty(), sortingCode_,
            !other.sortingCode_.isEmpty(), other.sortingCode_);
        administrativeArea_ = visitor.visitString(!administrativeArea_.isEmpty(), administrativeArea_,
            !other.administrativeArea_.isEmpty(), other.administrativeArea_);
        locality_ = visitor.visitString(!locality_.isEmpty(), locality_,
            !other.locality_.isEmpty(), other.locality_);
        sublocality_ = visitor.visitString(!sublocality_.isEmpty(), sublocality_,
            !other.sublocality_.isEmpty(), other.sublocality_);
        addressLines_= visitor.visitList(addressLines_, other.addressLines_);
        recipients_= visitor.visitList(recipients_, other.recipients_);
        organization_ = visitor.visitString(!organization_.isEmpty(), organization_,
            !other.organization_.isEmpty(), other.organization_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!input.skipField(tag)) {
                  done = true;
                }
                break;
              }
              case 8: {

                revision_ = input.readInt32();
                break;
              }
              case 18: {
                String s = input.readStringRequireUtf8();

                regionCode_ = s;
                break;
              }
              case 26: {
                String s = input.readStringRequireUtf8();

                languageCode_ = s;
                break;
              }
              case 34: {
                String s = input.readStringRequireUtf8();

                postalCode_ = s;
                break;
              }
              case 42: {
                String s = input.readStringRequireUtf8();

                sortingCode_ = s;
                break;
              }
              case 50: {
                String s = input.readStringRequireUtf8();

                administrativeArea_ = s;
                break;
              }
              case 58: {
                String s = input.readStringRequireUtf8();

                locality_ = s;
                break;
              }
              case 66: {
                String s = input.readStringRequireUtf8();

                sublocality_ = s;
                break;
              }
              case 74: {
                String s = input.readStringRequireUtf8();
                if (!addressLines_.isModifiable()) {
                  addressLines_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(addressLines_);
                }
                addressLines_.add(s);
                break;
              }
              case 82: {
                String s = input.readStringRequireUtf8();
                if (!recipients_.isModifiable()) {
                  recipients_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(recipients_);
                }
                recipients_.add(s);
                break;
              }
              case 90: {
                String s = input.readStringRequireUtf8();

                organization_ = s;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (com.google.type.PostalAddress.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:google.type.PostalAddress)
  private static final com.google.type.PostalAddress DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new PostalAddress();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static com.google.type.PostalAddress getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<PostalAddress> PARSER;

  public static com.google.protobuf.Parser<PostalAddress> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

